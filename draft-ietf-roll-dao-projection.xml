<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">


<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="3"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc authorship="yes"?>
<?rfc tocappendix="yes"?>
<rfc  xmlns:xi="http://www.w3.org/2001/XInclude" category="std" ipr='trust200902'
tocInclude="true" indexInclude="true" obsoletes=""  consensus="true"
submissionType="IETF" xml:lang="en" version="3"
docName="draft-ietf-roll-dao-projection-20" >

<front>

   <title abbrev='DAO Projection'>Root initiated routing state in RPL</title>
   <author initials='P' surname='Thubert' fullname='Pascal Thubert' role='editor'>
      <organization abbrev='Cisco Systems'>Cisco Systems, Inc</organization>
      <address>
         <postal>
            <street>Building D</street>
            <street>45 Allee des Ormes - BP1200 </street>
            <city>Mougins - Sophia Antipolis</city>
            <code>06254</code>
          <country>France</country>
         </postal>
         <phone>+33 497 23 26 34</phone>
         <email>pthubert@cisco.com</email>
      </address>
   </author>

    <author fullname="Rahul Arvind Jadhav" initials="R.A." surname="Jadhav">
        <organization>Huawei Tech</organization>
        <address>
            <postal>
                <street>Kundalahalli Village, Whitefield,</street>
                <city>Bangalore</city>
                <region>Karnataka</region>
                <code>560037</code>
                <country>India</country>
            </postal>
            <phone>+91-080-49160700</phone>
            <email>rahul.ietf@gmail.com</email>
        </address>
    </author>

<author initials='M' surname='Gillmore' fullname='Matthew Gillmore'>
      <organization abbrev='Itron'>Itron, Inc</organization>
      <address>
         <postal>
            <street>Building D</street>
            <street>2111 N Molter Road</street>
            <city>Liberty Lake</city>
            <code>99019</code>
            <country>United States</country>
         </postal>
         <phone>+1.800.635.5461</phone>
         <email>matthew.gillmore@itron.com</email>
      </address>
   </author>

        <date/>

	<area>Routing</area>

	<workgroup>ROLL</workgroup>

        <abstract>
	  <t>
     This document extends RFC 6550, RFC 6553,and RFC 8138 to enable a RPL Root
     to install and maintain Projected Routes within its DODAG, along a selected
     set of nodes that may or may not include self, for a chosen duration.
     This potentially enables routes
    that are more optimized or resilient than those obtained with the
    classical distributed operation of RPL, either in terms of the size of a
    Routing Header or in terms of path length, which impacts both the
    latency and the packet delivery ratio.
	  </t>
	</abstract>
    </front>

    <middle>

	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<section anchor='introduction'><name>Introduction</name>

	   <t> RPL, the <xref target='RFC6550'>
   "Routing Protocol for Low Power and Lossy Networks"</xref> (LLNs),
   is an anisotropic Distance Vector protocol that is well-suited
   for application in a variety of low energy Internet of Things (IoT)
   networks where stretched P2P paths are acceptable vs. the signaling
   and state overhead involved in maintaining shortest paths across.
    </t>
<t>
   RPL forms Destination Oriented Directed Acyclic Graphs (DODAGs) in which
   the Root often acts as the Border Router to connect the RPL domain to the
   IP backbone and routes along that graph up, towards the Root, and down
   towards the nodes.
    </t>
<t>
   With this specification, a Path Computation Element <xref target='PCE'/> in
   an external controller interacts with the RPL Root to compute centrally
   shorter Peer to Peer (P2P) paths within the RPL DODAG.
   The topological information that is passed to the PCE is derived from the
   DODAG that is already available at the Root in RPL Non-Storing Mode. This
   specification introduces protocol extensions that enrich the topological
   information that is available at the Root and passed to the PCE.
    </t>
<t>
   Based on usage, path length, and knowledge of available resources such as
   battery levels and reservable buffers in the nodes, the PCE with a global
   visibility on the system can optimize the computed routes for the
   application needs, including the capability to provide path redundancy.
   This specification also introduces protocol extensions that enable the
   Root to translates the computed paths into RPL and install them as
   Projected Routes inside the DODAG on behalf of a PCE.
   </t>
    </section>

	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->

<section><name>Terminology</name>
<section anchor='bcp'><name>Requirements Language</name>
<t>

    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
    "OPTIONAL" in this document are to be interpreted as described in BCP 14
    <xref target='RFC2119'/><xref target='RFC8174'/> when, and only when, they
    appear in all capitals, as shown here.

</t>
</section>	<!-- end section "Requirements Language" -->

  <section anchor='lo'><name>References</name>
    <t>
	In this document, readers will encounter terms and concepts
	that are discussed in the <xref target='RFC6550'>"Routing Protocol for Low Power and Lossy Networks"</xref>, the <xref target='RFC9030'> "6TiSCH Architecture"</xref>, the <xref target='RFC8655'>
    "Deterministic Networking Architecture"</xref>, the <xref target='I-D.ietf-raw-architecture'>"Reliable and
    Available Wireless (RAW) Architecture/Framework"</xref>,
    and
    <xref target='RFC7102'>"Terminology in Low power And Lossy Networks"</xref>.
    </t>
  </section>	<!-- end section "References" -->



<section anchor='gloss'><name>Glossary</name>
    <t> This document often uses the following acronyms:
       </t><dl spacing='compact'>
       <dt>CMO:</dt><dd> Control Message Option</dd>
       <dt>DAO:</dt><dd> Destination Advertisement Object</dd>
       <dt>DAG:</dt><dd> Directed Acyclic Graph </dd>
       <dt>DODAG:</dt><dd> Destination-Oriented Directed Acyclic Graph; A DAG
       with only one vertex (i.e., node) that has no outgoing edge (i.e., link)
       </dd>
       <dt>LLN:</dt><dd> Low-Power and Lossy Network </dd>
       <dt>MOP:</dt><dd> RPL Mode of Operation</dd>
       <dt>P-DAO:</dt><dd> Projected DAO </dd>
       <dt>P-Route:</dt><dd> Projected Route </dd>
       <dt>PDR:</dt><dd> P-DAO Request </dd>
       <dt>RAN:</dt><dd> RPL-Aware Node (either a RPL Router or a RPL-Aware Leaf)</dd>
       <dt>RAL:</dt><dd> RPL-Aware Leaf </dd>
       <dt>RH:</dt><dd> Routing Header </dd>
       <dt>RPI:</dt><dd> RPL Packet Information </dd>
       <dt>RTO:</dt><dd> RPL Target Option</dd>
       <dt>RUL:</dt><dd> RPL-Unaware Leaf </dd>
       <dt>SIO:</dt><dd> RPL Sibling Information Option</dd>
       <dt>NSM-VIO:</dt><dd> A Source-Routed Via Information Option, used in Non-Storing-Mode P-DAO messages.    </dd>
       <!--
       <dt>SubDAG:</dt><dd> A DODAG Rooted at a node which is a child of that
       node and a subset of a larger DAG</dd> -->
       <dt>TIO:</dt><dd> RPL Transit Information Option</dd>
       <dt>SM-VIO:</dt><dd> A strict Via Information Option, used in Storing-Mode P-DAO messages.    </dd>
       <dt>VIO:</dt><dd> A Via Information Option; it can be a SM-VIO or an NSM-VIO.    </dd>
       </dl>

</section>	<!-- Glossary -->



<section anchor='new'><name>Domain Terms</name>
    <t>
    <!-- Removed reference from routing and 6tisch here to keep it simple
	 This specification introduces the following terminology:-->
    </t><dl spacing='compact'>

    <dt>Projected Route:</dt><dd>
	A RPL P-Route is a RPL route that is computed remotely by a PCE, and installed and maintained by a RPL Root on behalf of the PCE.</dd>

    <dt>Projected DAO:</dt><dd> A DAO message used to install a P-Route. </dd>
    <dt>Path:</dt><dd>
    <t>
    Quoting section 1.1.3 of <xref target="RFC1122"/>:
    "At a given moment, all the IP datagrams from a particular source host to a
    particular destination host will typically traverse the same sequence of
    gateways.  We use the term "path" for this sequence.  Note that a path is
    uni-directional; it is not unusual to have different paths in the two
    directions between a given host pair.".
    </t>
    <t>
    Section 2 of <xref target="I-D.irtf-panrg-path-properties"/> points to a longer, more modern definition of path, which begins as follows:
    "
      A sequence of adjacent path elements over which a packet can
      be transmitted, starting and ending with a node.  A path is
      unidirectional.  Paths are time-dependent, i.e., the sequence of
      path elements over which packets are sent from one node to another
      may change.  A path is defined between two nodes.
    "
    </t>
    <t>
    It follows that the general acceptance of a path is a linear sequence of
    nodes, as opposed to a multi-dimensional graph. In the context of this
    document, a path is observed by following one copy of a packet that is
    injected in a Track and possibly replicated within.
    </t>
    </dd>
    <dt>Track:</dt><dd>
    <t>A networking graph that can be followed to transport packets with
    equivalent treatment; as opposed to the definition of a path above,
    a Track Track is not necessarily linear. It may contain multiple paths that
    may fork and rejoin, and may enable the RAW Packet ARQ, Replication,
    Elimination, and Overhearing (PAREO) operations.
    </t>
    <t>
    This specification builds Tracks that are DODAGs oriented towards a Root,
    which is the Track Ingress, and the forward direction for packets is
    East-West from the Track Ingress to one of the possibly multiple Track Egress
    Nodes, which is also down the DODAG.
    </t>
    <t>
    The Track may be strictly connected, meaning that the vertices are adjacent, or loosely connected, meaning that the vertices are connected using Segments that are associated to the same Track.
    </t>
    </dd>
    <dt>TrackID:</dt><dd>
    A RPL Local InstanceID with the D bit set to 0. The TrackID is associated with the IPv6 Address of the Track Ingress that is used to signal the DODAG Root, and together they form a unique identification of the Track
    (see the definition of DODAGID in section 2 of <xref target='RFC6550'/>.
    </dd>
    <dt>Serial Track:</dt><dd>A Track that has only one path.
    </dd>
    <dt>Stand-Alone:</dt><dd>
    A single P-DAO that fully defines a Track, e.g., a Serial Track installed
    with a single Storing Mode Via Information option (SM-VIO).
    </dd>
    <dt>subTrack:</dt><dd>A Track within a Track. As the Non-Storing Mode Via
    Information option (NSM-VIO) can only signal a loose sequence of nodes, it
    takes a number of them to signal a complex Track. Each NSM-VIO for the same
    tackId but a different Segment ID signals a different subTrack that the
    Track Ingress adds to the topology.
    </dd>
    <dt>Track Leg:</dt><dd>An end-to-end East-West serial path that can be a
    Track by itself or a subTrack of a multilegged Track.
    With this specification, a Leg is expressed as a loose sequence of nodes
    that are joined by Track Segments.
    </dd>
    <dt>Track Segment:</dt><dd>
    A serial path formed by a strict sequence of nodes, along which a route is
    installed.
    With this specification, a Segment is installed by the Root of the main
    DODAG using Storing-Mode P-DAO messages. A Segment is typically used as
    the topological edge of a Track. Since this specification builds only DODAGs,
    all Segments are oriented from Ingress (East) to Egress (West), as opposed
    to the general RAW model, which allows North/South Segments that can be
    bidirectional.
    </dd>

    </dl>
</section>	<!-- end section "Domain Terms" -->

</section>	<!-- end section "Terminology" -->


<section anchor='context'><name>Context and Goal</name>

<section anchor='onrpl'><name>RPL Applicability</name>
<t>
   RPL is optimized for situations where the power is scarce, the bandwidth
   constrained and the transmissions unreliable. This matches the use case of
   an IoT LLN where RPL is typically used today, but also situations of high relative mobility between the nodes in the network (aka swarming), e.g.,
   within a variable set of vehicles with a similar global motion, or a toon of
   drones.
</t><t>
   To reach this goal, RPL is primarily designed to minimize the control plane
   activity, that is the relative amount of routing protocol exchanges vs. data
   traffic, and the amount of state that is maintained in each node. RPL does
   not need converge, and provides connectivity to most nodes most of the time.
</t><t>
    RPL may form multiple topologies called instances. Instances can be
    created to enforce various optimizations through objective functions,
    or to reach out through different Root Nodes.  The concept of objective
    function allows to adapt the activity of the routing protocol to the use
    case, e.g., type, speed, and quality of the LLN links.
</t><t>
    RPL instances operate as ships in the night, unbeknownst of one another.
    The RPL Root is responsible to select the RPL Instance that is used
    to forward a packet coming from the Backbone into the RPL domain and set
    the related RPL information in the packets. 6TiSCH leverages RPL for its
    distributed routing operations.
</t><t>
   To reduce the routing exchanges, RPL leverages an anisotropic Distance Vector
   approach, which does not need a global knowledge of the topology, and only
   optimizes the routes to and from the root, allowing P2P paths to be
   stretched. Although RPL installs its routes proactively, it only maintains
   them lazily, in reaction to actual traffic, or as a slow background activity.
</t><t>
   This is simple and efficient in situations where the traffic is mostly
   directed from or to a central node, such as the control traffic between
   routers and a controller of a Software Defined Networking (SDN) infrastructure or an Autonomic Control Plane (ACP).
</t><t>
   But stretch in P2P routing is counter-productive to both reliability and
   latency as it introduces additional delay and chances of loss. As a result,
   <xref target='RFC6550'/> is not a good fit for the use cases listed in the
   RAW use cases document <xref target= 'I-D.ietf-raw-use-cases'/>, which demand
   high availability and reliability, and as a consequence require both short
   and diverse paths.
</t>

</section>	<!-- end section "RPL Applicability" -->
<section anchor='onrplroute'><name>RPL Routing Modes</name>
<t>
   RPL first forms a default route in each node towards the a Root, and those
   routes together coalesce as a Directed Acyclic Graph upwards.
   RPL then constructs routes to so-called Targets in the reverse direction,
   down the same DODAG. So do so, a RPL Instance can be operated either in RPL
   Storing or Non-Storing Mode of Operation (MOP)
   The default route towards the Root is maintained aggressively and may change while a packet progresses without causing loops, so the packet will still reach the root.
</t>
<t>In Non-Storing Mode, each node advertises itself as a target directly to the
   Root, indicating the parents that may be used to reach self. Recursively, the
   Root builds and maintains an image of the whole DODAG in memory, and
   leverages that abstraction to compute source route paths for the packets to
   their destinations down the DODAG. When a node changes its point(s)
   of attachment to the DODAG, it takes single unicast packet to the Root along
   the default route to update it, and the connectivity is restored immediately;
   this mode is preferable for use cases where internet connectivity is
   dominant, or when, like here, the Root controls the network activity in the
   nodes.
</t>
<t>In Storing Mode, the routing information percolates upwards, and each node
   maintains the routes to the subDAG of its descendants down the DODAG.
   The maintenance is lazy, either reactive upon traffic or as a slow background
   process. Packets flow via the common parent and the routing stretch is
   reduced vs. Non-Storing, for a better P2P connectivity, while the internet
   connectivity is restored more slowly, time for the DV operation to operate
   hop-by-hop.
</t>

    <t>
    Either way, the RPL routes are injected by the Target nodes, in a distributed fashion. To complement RPL and eliminate routing stretch, this specification introduces an hybrid mode that combines Storing and Non-Storing operations to build and project routes onto the nodes where they should be installed. This specification uses the term Projected Route (P-Route) to refer to those routes.
    </t>
    <t>
    A P-Route may be installed in either Storing and Non-Storing Mode,
    potentially resulting in hybrid situations where the Mode of the P-
    Route is different from that of the main RPL Instance.
    P-Routes can be used as stand-alone segments to reduce the size of the
    source routing headers with loose source routing operations down the main RPL DODAG.
    P-Routes can also be combined with other P-Routes to form a more complex forwarding graph called a Track.
    </t>

</section>	<!-- end section "RPL Routing Modes" -->



<section anchor='tracks'><name>On Tracks</name>

<t> A Track is
   typically a collection of parallel loose source routed sequences of nodes
   from Ingress to Egress, forming so-called Track Legs, that are joined with
   strict Segments of other nodes. The Legs are expressed in RPL Non-Storing
   Modes and require an encapsulation to add a Source Route Header, whereas
   the Segments are expressed in Storing Mode.
</t>
<t>
   A Serial Track comprises provides only one path between Ingress and Egress.
   It comprises at most one Leg. A Stand-Alone Segment defines implicitly a
   Serial Track from its Ingress to Egress.
</t>

<t> A complex Track forms a graph that provides a collection of potential paths
    to provide redundancy for the packets, either as a collection of Legs that
    may be parallel or cross at certain points, or as a more generic DODAG
    that is rooted at the Ingress Node.
</t>


    <t>
    The concept of a Track was introduced in the <xref target='RFC9030'>
    "6TiSCH Architecture"</xref>, as a collection of potential paths that
    leverage redundant forwarding solutions along the way.
    With this specification, a Track is a DODAG formed by a RPL local Instance
    that is Rooted at the Track Ingress.  If there is a single Track Egress,
    then the Track is reversible to form another DODAG by reversing the
    direction of each edge. A node at the Ingress of more
    than one Segment in a Track may use one or more of these Segments to forward
    a packet inside the Track.
    </t>

   <t>
   When building a Track with RPL, the Track is assimilated with the DODAG
   formed for a Local RPL Instance.
   The local RPLInstanceID of the Track is used as the TrackID, more in
   <xref target='trkid'/>. This does not change the semantics and format of the
   RPLInstanceID that is used as TrackID.
   A P-DAO message for a Track signals the TrackID in
   the RPLInstanceID field. The Track Ingress is signaled in the DODAGID field
   of the Projected DAO Base Object; that field is elided in the case of the
   main RPL Instance. The Track Ingress is the Root of the Track, as shown in
   <xref target='p-dao-fmt'/>.
   </t>

</section><!-- On tracks -->




    <section><name>Serial Track Signaling</name>
<t>
   This specification introduces the concept of a Projected Route (P-Route)
   along either a Track Leg or a Segment. A P-Route is installed and maintained
   using an extended RPL DAO message called a Projected DAO (P-DAO), and a Track
   is composed of the combination of one or more P-Routes. This specification
   introduces the Via Information Option (VIO) to signal a sequence of hops in a
   Leg or a Segment in the P-DAO messages, either in Storing Mode (SM-VIO) or
   NON-Storing Mode (NSM-VIO). One P-DAO messages contains a single VIO,
   associated to one or more RPL Target Options that signal the destination
   IPv6 addresses that can reached along the Track.
</t>
<t>
   Before diving deeper into Track Legs and Segments signalling and operation,
   this section provides examples of what how route projection works through
   variations of a simple example. Say we want to build a Serial Track from
   node A to E in <xref target='reft'/>, so A can route packets to either E or
   its neighbors F and G along A, B, C, D and E as opposed to via the Root:
</t>

<figure anchor='reft'><name>Reference Track</name>
              <artwork align="center">
                               ===&gt; F
A ===&gt; B ===&gt; C ===&gt; D===&gt; E &lt;
                               ===&gt; G

 </artwork>
</figure>

<t>
In this example,
A is Track Ingress, E is Track Egress. C is a stitching point. F and G are
“external” targets for the Track, and become reachable from A  over the Track
A->E.
</t>

<t>
In a general manner the desired outcome is as follows:
</t>

<ul>
<li>P-DAO 1 signals C==&gt;D==&gt;E</li>
<li>P-DAO 2 signals A==&gt;B==&gt;C</li>
<li>P-DAO 3 signals F and G via the A==&gt;E Track</li>
</ul>

<t>
   Loose sequences of hops must be expressed in Non-Storing Mode, so P-DAO 3
   contains a NSM-VIO. Since the Root of the Track is always its Ingress and the
   Root address is signaled in the DAO base object, it is not needed in the via
   list in NSM-VIO, so the via list starts at the first loose hop.
</t>



    <section><name>Using Storing-Mode Segments</name>
<t>
    A==&gt;B==&gt;C and C==&gt;D==&gt;E are segments of a same Track.
    Note that the Storing Mode signaling imposes strict continuity in a segment.
    One benefit of strict routing is that loops are avoided along the Track.
</t>

    <section><name>Stitched Segments</name>

<t>Storing-Mode P-DAO 1 and 2 are sent to E and C, as follows:</t>

        <table anchor="PDAOcase11"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'>Field</th>
              <th align='left'>P-DAO 1 to E</th>
              <th align='left'>P-DAO 2 to C</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Storing</td>
              <td align='left'>Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>TrackID</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>C, D, E</td>
              <td align='left'>A, B, C</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>E, F, G</td>
              <td align='left'>E, F, G</td></tr>

    </tbody>
        </table>

<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase11"><name>RIB setting</name>
   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>E</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>C</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>(A, 129)</td></tr>


    </tbody>
        </table>




<t>
    E recognizes that it is the Track Egress because it is both a Target and a
    Segment Endpoint.
</t>
<t>
    Packets originated by A to E, F, or G, do not require an encapsulation.
    In any fashion,
    the outer headers of the packets that are forwarded along the Track have
    the following settings:
</t>


   <table anchor="Packetcase11"><name>Packet header settings</name>  <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>E, F or G</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X != A</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>
<t>
As an example, say that A has a packet for F. Using the RIB above:
</t>
<ul>
<li>From P-DAO 2: A forwards to B and B forwards to C.</li>
<li>From P-DAO 1: C forwards to D and D forwards to E.</li>
<li>From Neighbor Cache Entry: C delivers the packet to F.</li>
</ul>

    </section><!-- Stitched Segments -->

    <section><name>External routes</name>

<t>Storing-Mode P-DAO 1 and 2, and Non-Storing-Mode P-DAO 3, are sent to E, C
 and A, respectively, as follows:</t>

        <table anchor="PDAOcase12"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to E</th>
              <th align='left'>P-DAO 2 to C</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Storing</td>
              <td align='left'>Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>A</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>TrackID</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>C, D, E</td>
              <td align='left'>A, B, C</td>
              <td align='left'>E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>E</td>
              <td align='left'>E</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>

<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase12"><name>RIB setting</name>
   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>C</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>(A, 129)</td></tr>


    </tbody>
        </table>

        <!--
<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase12o"><name>RIB setting</name>
   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Control Message</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>Destination</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>F</td>
              <td align='left'>F</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>G</td>
              <td align='left'>G</td></tr>

          <tr><td align='center'>D</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>E</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'>C</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>D</td>
              <td align='left'>D</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>C</td>
              <td align='left'>C</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>C</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'>A</td>
              <td align='left'>NS(EARO)</td>
              <td align='left'>B</td>
              <td align='left'>B</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>E</td></tr>

          <tr><td align='center'> </td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>E</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>F</td></tr>
          <tr><td align='center'> </td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>G</td></tr>


    </tbody>
        </table>
        -->

<t>
    Packets from A to E do not require an encapsulation. In any fashion,
    the outer headers of the packets that are forwarded along the Track have
    the following settings:
</t>


        <table anchor="Packetcase12"><name>Packet header settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>E</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E (X != A), F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>
<t>
As an example, say that A has a packet for F. Using the RIB above:
</t>
<ul>
<li>From P-DAO 3: A encapsulates the packet the Track signaled by P-DAO 3, with the outer header above.
Now the packet destination is E.</li>
<li>From P-DAO 2: A forwards to B and B forwards to C.</li>
<li>From P-DAO 1: C forwards to D and D forwards to E; E decapsulates the packet.</li>
<li>From Neighbor Cache Entry: C delivers packets to F or G.</li>
</ul>
    </section><!-- External routes -->

    <section><name>Segment Routing</name>

<t>Storing-Mode P-DAO 1 and 2, and Non-Storing-Mode P-DAO 3, are sent to E, B
 and A, respectively, as follows:</t>

        <table anchor="PDAOcase13"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to E</th>
              <th align='left'>P-DAO 2 to B</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Storing</td>
              <td align='left'>Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>A</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>TrackID</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 129)</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>C, D, E</td>
              <td align='left'>A, B</td>
              <td align='left'>C, E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>E</td>
              <td align='left'>B, C</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>
<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase13"><name>RIB setting</name>
           <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>Neighbor</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B</td>
              <td align='left'>(A, 129)</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>C, E</td>
              <td align='left'>(A, 129)</td></tr>



    </tbody>
        </table>



<t>
    Packets from A to E do not require an encapsulation, but carry a SRH via C.
    In any fashion,
    the outer headers of the packets that are forwarded along the Track have
    the following settings:
</t>
        <table anchor="Packetcase13"><name>Packet header settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>C till C then E</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E (X != A), F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>
<t>
As an example, say that A has a packet for F. Using the RIB above:
</t>
<ul>
<li>From P-DAO 3: A encapsulates the packet the Track signaled by P-DAO 3, with the outer header above.
Now the destination in the IPv6 Header is C, and a SRH signals the final destination is E.</li>
<li>From P-DAO 2: A forwards to B and B forwards to C.</li>
<li>From P-DAO 3: C processes the SRH and sets the destination in the IPv6 Header to E.</li>
<li>From P-DAO 1: C forwards to D and D forwards to E; E decapsulates the packet.</li>
<li>From the Neighbor Cache Entry: C delivers packets to F or G.</li>
</ul>

    </section><!-- Segment Routing -->



    </section><!-- Using Storing-Mode Segments -->




    <section><name>Using Non-Storing-Mode joining Tracks</name>

<t>
    A==&gt;B==&gt;C and C==&gt;D==&gt;E are Tracks expressed as Non-Storing P-DAOs.

</t>

    <section><name>Stitched Tracks</name>

    <t>
    Non-Storing Mode P-DAO 1 and 2 are sent to C and A respectively, as follows:
    </t>

        <table anchor="PDAOcase21"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to C</th>
              <th align='left'>P-DAO 2 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>C</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>TrackID</td>
              <td align='left'>(C, 131)</td>
              <td align='left'>(A, 129)</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>D, E</td>
              <td align='left'>B, C</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>F, G</td>
              <td align='left'>E, F, G</td></tr>

    </tbody>
        </table>


<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase21"><name>RIB setting</name>
           <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D, E</td>
              <td align='left'>(C, 131)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C, E, F, G</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B, C</td>
              <td align='left'>(A, 129)</td></tr>


    </tbody>
        </table>



<t>
    Packets from A to E, F and G do not require an encapsulation, though it is
    preferred that A encapsulates and C decapsulates. Either way, they
    carry a SRH via B and C, and C needs to encapsulate to E, F, or G
    to add an SRH via D and E.
    The encapsulating headers of packets that are forwarded along the Track
    between C and E have the following settings:
</t>


        <table anchor="Packetcase21"><name>Packet header settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>C</td>
              <td align='center'>D till D then E</td>
              <td align='center'>(C, 131)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F, or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>


<t>As an example, say that A has a packet for F.  Using the RIB above:</t>
<ul>
<li>From P-DAO 2:
A encapsulates the packet with destination of F in the Track signaled by P-DAO 2. The outer header has source A, destination B, an SRH that indicates C as the next loose hop, and a RPI indicating a TrackId of 129 from A's namespace.
</li>
<li>From the SRH:
Packets forwarded by B have source A, destination C , a consumed SRH, and a RPI indicating a TrackId of 129 from A's namespace. C decapsulates.
</li>
<li>
From P-DAO 1:
C encapsulates the packet with destination of F in the Track signaled by P-DAO 1. The outer header has source C, destination D, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 131 from C's namespace. E decapsulates.
</li>
</ul>

    </section><!-- Stitched Tracks -->

    <section><name>External routes</name>

    <t>
    Non-Storing Mode P-DAO 1 is sent to C and Non-Storing Mode P-DAO 2 and 3 are sent A, as follows:
    </t>

        <table anchor="PDAOcase22"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to C</th>
              <th align='left'>P-DAO 2 to A</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>C</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>TrackID</td>
              <td align='left'>(C, 131)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 141)</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>D, E</td>
              <td align='left'>B, C</td>
              <td align='left'>E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'>E</td>
              <td align='left'>E</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>

<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase22"><name>RIB setting</name>
                   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D, E</td>
              <td align='left'>(C, 131)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C, E</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B, C</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>"</td>
              <td align='left'>F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>E</td>
              <td align='left'>(A, 141)</td></tr>


    </tbody>
        </table>

<t>
    The encapsulating headers of packets that are forwarded along the Track
    between C and E have the following settings:
</t>


        <table anchor="Packetcase22"><name>Packet header settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>C</td>
              <td align='center'>D till D then E</td>
              <td align='center'>(C, 131)</td></tr>
          <tr><td align='center'>Middle</td>
              <td align='center'>A</td>
              <td align='center'>E</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

    <!--
          1.  non Storing Mode P-DAO 1 is sent to C. It has Root = C, SRVIO = D, E, Track ID 131 from C's namespace, Target = E
      2.  non Storing Mode P-DAO 2 is then sent to A. It has Root = A, SRVIO = B, C, Track ID 129 from A's namespace, Target = E
      3.  non Storing Mode P-DAO 3 is then sent to A. It has Root = A, SRVIO = E, Track ID 141 from A's namespace, Target = F, G



    >From P-DAO 3: A encapsulates packets with dest =   F | G. The outer header has source = A, destination = E, and RPI = 141.
    This may recurse with:
    >From P-DAO 2: A encapsulates packets with dest =  E. The outer header has source = A, destination = B, SRH = C and RPI = 129.
    Packets forwarded by B have source= A, destination = C , SRH =, and RPI = 129. C decapsulates.
    >From P-DAO 1: C  encapsulates packets with dest =  E. The outer header has source= C, destination = D, SRH = E and RPI = 131.
    E decapsulates if encapsulated.
    -->


<t>As an example, say that A has a packet for F.  Using the RIB above:</t>
<ul>
<li>
From P-DAO 3: A encapsulates the packet with destination of F in the Track signaled by P-DAO 3. The outer header has source A, destination E, and a RPI indicating a TrackId of 141 from A's namespace. This recurses with:
</li>
<li>
From P-DAO 2: A encapsulates the packet with destination of E in the Track signaled by P-DAO 2. The outer header has source A, destination B, an SRH that indicates C as the next loose hop, and a RPI indicating a TrackId of 129 from A's namespace.
</li>
<li>
From the SRH:
Packets forwarded by B have source A, destination C , a consumed SRH, and a RPI indicating a TrackId of 129 from A's namespace. C decapsulates.
</li>
<li>
From P-DAO 1:
C encapsulates the packet with destination of E in the Track signaled by P-DAO 1. The outer header has source C, destination D, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 131 from C's namespace. E decapsulates.
</li>
</ul>

    </section><!-- External routes -->

    <section><name>Segment Routing</name>



    <t>
    Non-Storing Mode P-DAO 1 is sent to C and Non-Storing Mode P-DAO 2 and 3 are sent A, as follows:
    </t>

        <table anchor="PDAOcase23"><name>P-DAO Messages</name>
   <thead>

          <tr><th align='center'> </th>
              <th align='left'>P-DAO 1 to C</th>
              <th align='left'>P-DAO 2 to A</th>
              <th align='left'>P-DAO 3 to A</th></tr>

   </thead>
   <tbody>

          <tr><td align='center'>Mode</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td>
              <td align='left'>Non-Storing</td></tr>
          <tr><td align='center'>Track Ingress</td>
              <td align='left'>C</td>
              <td align='left'>A</td>
              <td align='left'>A</td></tr>
          <tr><td align='center'>TrackID</td>
              <td align='left'>(C, 131)</td>
              <td align='left'>(A, 129)</td>
              <td align='left'>(A, 141)</td></tr>
          <tr><td align='center'>VIO</td>
              <td align='left'>D, E</td>
              <td align='left'>B</td>
              <td align='left'>C, E</td></tr>
          <tr><td align='center'>Targets</td>
              <td align='left'></td>
              <td align='left'>C</td>
              <td align='left'>F, G</td></tr>

    </tbody>
        </table>



<t>As a result the RIBs are set as follows:</t>

        <table anchor="RIBcase23"><name>RIB setting</name>
                   <thead>

          <tr><th align='center'>Node</th>
              <th align='left'>Destination</th>
              <th align='left'>Origin</th>
              <th align='left'>Next Hop(s)</th>
              <th align='left'>TrackID</th></tr>

   </thead>
      <tbody>

          <tr><td align='center'>E</td>
              <td align='left'>F, G</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>D</td>
              <td align='left'>E</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>C</td>
              <td align='left'>D</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>E</td>
              <td align='left'>P-DAO 1</td>
              <td align='left'>D, E</td>
              <td align='left'>(C, 131)</td></tr>

          <tr><td align='center'>B</td>
              <td align='left'>C</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>


          <tr><td align='center'>A</td>
              <td align='left'>B</td>
              <td align='left'>ND</td>
              <td align='left'>Neighbor</td>
              <td align='left'>Any</td></tr>

          <tr><td align='center'>"</td>
              <td align='left'>C</td>
              <td align='left'>P-DAO 2</td>
              <td align='left'>B, C</td>
              <td align='left'>(A, 129)</td></tr>


          <tr><td align='center'>"</td>
              <td align='left'>E, F, G</td>
              <td align='left'>P-DAO 3</td>
              <td align='left'>C, E</td>
              <td align='left'>(A, 141)</td></tr>


    </tbody>
        </table>

<t>
    The encapsulating headers of packets that are forwarded along the Track
    between A and B have the following settings:
</t>


        <table anchor="Packetcase231"><name>Packet header settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>B till D then E</td>
              <td align='center'>(A, 129)</td></tr>
          <tr><td align='center'>Middle</td>
              <td align='center'>A</td>
              <td align='center'>C</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

 <t>
    The encapsulating headers of packets that are forwarded along the Track
    between B and C have the following settings:
</t>


        <table anchor="Packetcase232"><name>Packet header settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>A</td>
              <td align='center'>C</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

<t>
    The encapsulating headers of packets that are forwarded along the Track
    between C and E have the following settings:
</t>


        <table anchor="Packetcase233"><name>Packet header settings</name>
   <thead>

          <tr><th align='center'>Header</th>
          <th align='center'>IPv6 Source Addr.</th>
              <th align='center'>IPv6 Dest. Addr.</th>
              <th align='center'>TrackID in RPI</th></tr>

   </thead>
   <tbody>
          <tr><td align='center'>Outer</td>
              <td align='center'>C</td>
              <td align='center'>D till D then E</td>
              <td align='center'>(C, 131)</td></tr>
          <tr><td align='center'>Middle</td>
              <td align='center'>A</td>
              <td align='center'>E</td>
              <td align='center'>(A, 141)</td></tr>
          <tr><td align='center'>Inner</td>
              <td align='center'>X</td>
              <td align='center'>E, F or G</td>
              <td align='center'>N/A</td></tr>
    </tbody>
        </table>

    <!--

      1.  non Storing Mode P-DAO 1 is sent to C. It has Root = C, SRVIO = D, E, Track ID 131 from C's namespace, (Target = E is implicit)
      2.  non Storing Mode P-DAO 2 is then sent to A. It has Root = A, SRVIO = B,  Track ID 129 from A's namespace, Target = C
      3.  non Storing Mode P-DAO 3 is then sent to A. It has Root = A, SRVIO = C, E, Track ID 141 from A's namespace, Target = F, G

  -->

<t>As an example, say that A has a packet for F.  Using the RIB above:</t>
<ul>
<li>From P-DAO 3: A encapsulates the packet with destination of F in the Track signaled by P-DAO 3. The outer header has source A, destination C, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 141 from A's namespace. This recurses with:
</li>
<li>
From P-DAO 2: A encapsulates the packet with destination of C in the Track signaled by P-DAO 2. The outer header has source A, destination B, and a RPI indicating a TrackId of 129 from A's namespace. B decapsulates forwards to C based on a sibling connected route.
</li>
<li>
From the SRH: C consumes the SRH and makes the destination E.
</li>
<li>
From P-DAO 1:
C encapsulates the packet with destination of E in the Track signaled by P-DAO 1. The outer header has source C, destination D, an SRH that indicates E as the next loose hop, and a RPI indicating a TrackId of 131 from C's namespace. E decapsulates.
</li>
</ul>

    </section><!-- Segment Routing -->


  </section><!-- Using Non-Storing-Mode joining Tracks -->


</section><!-- Example Track Signaling -->


<section anchor='concepts'><name>Complex Tracks</name>

<t>To increase the reliability of the P2P transmission, this specification
   enables to build a collection of Legs between the same Ingress and Egress Nodes and combine them with the same TrackID, as shown in <xref target="FigLegs"/>. Legs may cross at loose hops edges or remain parallel.
</t><t>
   The Segments that join the loose hops of a Leg are installed with the same TrackID as the Leg. But each individual Leg and Segment has its own
   SegmentID which allows to manage it separately. When Legs cross within
   respsective Segment, the next loose hop (the current destination of the
   packet) indicates which Leg is being followed and a Segment that can reach
   that next loose hop is selected.
</t>
<figure anchor="FigLegs">
          <name>Segments and Tracks</name>
       <artwork align="center" name="" type="" alt="">
<![CDATA[
        CPF               CPF          CPF                 CPF

                       Southbound API

   _-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-
 _-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-._-

                      +----------+
                      | RPL Root |
                      +----------+
                        (      )
              (                                  )
        (              DODAG                              )
          (                                           )
  (                                                         )
                                                                  )
  <-    Leg 1            B,                            E ->
  <--- Segment 1 A,B ---> <------- Segment 2 C,D,E ------->

             FWD  --z  Relay --z   FWD  --z   FWD          Target 1
         z-- Node  z--  Node  z--  Node  z--  Node --z     /
      --z    (A)        (B) \      (C)        (D)  z--    /
Track                        \                       Track
Ingress                    Segment 5                 Egress - Tgt 2
  (I)                           \                     (E)
      --z                        \                 z--    \
       z-- FWD   --z  FWD  --z  Relay --z  FWD  --z        \
           Node   z-- Node  z-- Node   z-- Node            Target 3
           (F)        (G)       (H)        (J)

  <------ Segment 3 F,G,H ------> <---- Segment 4 J,E ---->
  <-      Leg 2                  H,                    E ->

  <--- Segment 1 A,B ---> <- S5-> <---- Segment 4 J,E ---->
  <-      Leg 3          B,      H,                    E ->
                                                                  )
   (
              (                                        )
]]></artwork>
</figure>


<t>
   Note that while this specification enables to build both Segments inside a
   Leg (aka East-West), such as Segment 2 above which is within Leg 1, and Inter-Leg Segments (aka North-South), such as Segment 2 above which joins
   Leg 1 and Leg 2, it does not signal to the Ingress which Inter-Leg Segments
   are available, so the use of North-South Segments and associated PAREO
   functions is curently limited. The only possibility available at this time
   is to define overlapping Legs as illustrated in <xref target="FigLegs"/>,
   with Leg 3 that is congruent with Leg 1 till node B and congruent with Leg
   2 from node H on, abstracting Segment 5 as an East-West Segment.
 </t>

<t>
   DetNet Forwarding Nodes only understand the simple 1-to-1 forwarding
   sublayer transport operation along a segment whereas the more sophisticated
   Relay nodes can also provide service sublayer functions such as Replication
   and Elimination. One possible mapping between DetNet and this specification
   is to signal the Relay Nodes as the hops of a Leg and the forwarding Nodes
   as the hops in a Segment that join the Relay nodes as illustrated in <xref
   target="FigLegs"/>.
</t>
</section>	<!-- Complex Tracks -->


<section anchor='inandout'><name>Scope and Expectations</name>

<t>
    This specification expects that the main RPL Instance is operated in RPL
    Non-Storing Mode to sustain the exchanges with the Root. Based on its
    comprehensive knowledge of the parent-child relationship, the Root can form
    an abstracted view of the whole DODAG topology. This document adds the
    capability for nodes to advertise additional sibling information to
    complement the topological awareness of the Root.
 </t><t>
    Projected Routes require resources such as routing table space in the
    routers and bandwidth on the links; the amount of state that
    is installed in each node must be computed to fit within the node's memory,
    and the amount of rerouted traffic must fit within the capabilities of
    the transmission links. The methods used to learn the node capabilities and
    the resources that are available in the devices and in the network are out
    of scope for this document. The method to capture and report the LLN link capacity and reliability statistics are also out of scope. They may be fetched from the nodes through network management functions or other forms of telemetry such as OAM.
</t>   <t>
    The <xref target='RFC9030'> "6TiSCH Architecture"</xref> leverages a centralized model that is similar to that of <xref target='RFC8655'>
    "Deterministic Networking Architecture"</xref>,
    whereby the device resources and capabilities are exposed to an external
    controller which installs routing states into the network based on its own
    objective functions that reside in that external entity. With DetNet and
    6TiSCH, the component of the controller that is responsible of computing
    routes is a PCE. The PCE
    computes its routes based on its own objective functions such as described
    in <xref target='RFC4655'/>, and typically controls the routes using the
    PCE Protocol (PCEP) by <xref target='RFC5551'/>.  While this specification
    expects a PCE and while PCEP might effectively be used between the Root and
    the PCE, the control protocol between the PCE and the Root is out of scope.
    </t>
    <t>
    This specification expects a single PCE with a full view of the network. Distributing the PCE function for a large network is out of scope.
    This specification uses the RPL Root as a proxy to the PCE. The PCE may be
    collocated with the Root, or may reside in an external Controller.
    In that case, the protocol between the Root and the PCE is out of scope
    and abstracted by / mapped to RPL inside the DODAG; one possibility is for
    the Root to transmit the RPL DAOs with the SIOs that detail the parent/child
    and sibling information.
    </t>
    <t>
    The algorithm to compute the paths and the protocol used by the PCE
    and the metrics and link statistics involved in the computation are also out
    of scope. The effectiveness of the route computation by the PCE depends on
    the quality of the metrics that are reported from the RPL network.
    Which metrics are used and how they are reported is out of scope, but the
    expectation is that they are mostly of long-term, statistical nature, and
    provide visibility on link throughput, latency, stability and availability
    over relatively long periods.
    </t>
    <t>
    The <xref target='I-D.ietf-raw-architecture'>"Reliable and Available
    Wireless (RAW) Architecture/Framework"</xref> extends the definition of
    Track, as being composed of East-West directional segments and North-South
    bidirectional segments, to enable additional path diversity, using Packet ARQ, Replication, Elimination, and Overhearing (PAREO) functions over the available paths, to provide a dynamic balance between the reliability and availability requirements of the flows and the need to conserve energy and spectrum.. This specification prepares for RAW by setting up the Tracks, but only forms DODAGs, which are composed  of aggregated end-to-end loose source routed Legs, joined by strict routed Segments, all oriented East-West.
     </t>
    <t>
    The RAW Architecture defines a dataplane extension of the PCE called the Path Selection Engine (PSE), that adapts the use of the path redundancy within a Track to defeat the diverse causes of packet loss.  The PSE controls the forwarding operation of the packets within a Track
    This specification can use but does not impose a PSE and does not provide
    the policies that wouldselect which packets are routed through which
    path within a Track, IOW, how the PSE may use the path redundancy within
    the Track. By default, the use of the available redundancy is limited to simple load balancing, and all the segments are East-West unidirectional only.
    </t>
    <t>
    A Track may be set up to reduce the load around the Root, or to enable
    urgent traffic to flow more directly. This specification does not provide
    the policies that would decide which flows are routed through which Track.
    In a Non-Storing Mode RPL Instance, the main DODAG provides a default route
    via the Root, and the Tracks provide more specific routes to the Track
    Targets.
    </t>



</section><!-- Scope and Expectations -->


</section ><!-- Context and Goal -->

  <section anchor='ext'><name>Extending existing RFCs </name>


    <section anchor='ext6550'><name>Extending RFC 6550</name>
    <t>
    This specification extends RPL <xref target='RFC6550'/> to enable the Root
    to install East-West routes inside a main DODAG that is operated as
    non-storing mode. A Projected DAO (P-DAO) message (see <xref target='extP-DAO'/>) contains a new Via Information Option that installs a strict
    or a loose sequence of hops to form respectively a Track Segment or a
    Track Leg.
    A new P-DAO Request (PDR) message (see <xref target='P-DAOreq'/>)
    enables a Track Ingress to request the Track from the  Root. In the
    context of this specification, the installed route appears as a more
    specific route to the Track targets, and the Track Ingress routes
    all the packets towards the targets via the Track.
    </t>
    <t>To ensure that the PDR and P-DAO messages can flow at most times,
    it is RECOMMENDED that the nodes involved in a Track mantain
    multiple parents in the  main DODAG, advertise them all to the Root,
    and use them in turn to retry similar packets. It is also
    RECOMMENDED that the Root uses diverse source route paths to retry
    similar messages ot the nodes in the Track.
    </t>
    <section anchor='extP-DAO'><name>Projected DAO</name>


   <t>
   Section 6 of <xref target='RFC6550'/> introduces the RPL Control Message
   Options (CMO), including the RPL Target Option (RTO) and Transit Information
   Option (TIO), which can be placed in RPL messages such as the Destination
   Advertisement Object (DAO). A DAO message signals routing information to one
   or more targets indicated in RTOs, providing one hop information at a time in
   the TIO. A Projected DAO (P-DAO) is a special DAO message generated by the
   Root to install a P-Route formed of multiple hops in its DODAG. This provides
   a RPL-based method to install the Tracks as expected by the 6TiSCH
   Architecture  <xref target='RFC9030'/> as a collection of multiple P-Routes.
   </t>
   <t>
   The P-DAO is signaled with a new "Projected DAO" (P) flag, see <xref target=
   'p-dao-fmt'/>. The 'P' flag is encoded in bit position 2 (to be confirmed by
   IANA) of the Flags field in the DAO Base Object. The Root MUST set it to 1 in
   a Projected DAO message. Otherwise it MUST be set to 0. It is set to 0 in
   Legacy implementations as specified respectively in Sections 20.11 and 6.4 of
   <xref target='RFC6550'/>
   </t>
   <t>
   The P-DAO ios control plabe signaling and should not be stuck behind high
   traffic levels. The expectation is that the P-DAO message is sent as high
   QoS level, above that of data traffic, typically with the Network Control
   precedence.
   </t>
<figure anchor='p-dao-fmt'><name>Projected DAO Base Object</name>
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    TrackID    |K|D|P|  Flags  |   Reserved    | DAOSequence   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
|                                                               |
+               IPv6 Address of the Track Ingress               +
|                                                               |
+                                                               +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Option(s)...
+-+-+-+-+-+-+-+-+
 </artwork>
</figure>


  <t> New fields:</t>
  <dl  spacing='normal'>

  <dt>TrackID:</dt>
    <dd> The RPLInstanceID of the DODAG that serves as Track , more in

    </dd>

  <dt>P:</dt>
    <dd> <t>1-bit flag (position to be confirmed by IANA).</t>
          <t>
          The 'P' flag is set to 1 by the Root to signal a Projected DAO,
          and it is set to 0 otherwise.
          </t>
          </dd>

  </dl>

  <t>
   In RPL Non-Storing Mode, the TIO and RTO are combined in a DAO message to
   inform the DODAG Root of all the edges in the DODAG, which are formed by the
   directed parent-child relationships.
   Options may be factorized; multiple RTOs may be present to signal a collection of children that can be reached via the parent(s) indicated in the TIO(s) that follows the RTOs.
   This specification generalizes the case of a parent that can be used to reach a child with that of a whole Track through which both children and siblings of the Track Egress are reachable.
   </t>
    </section> <!-- Projected DAO -->
    <section anchor='extVIO'><name>Via Information Option</name>
  <t>
   New CMOs called the Via Information Options (VIO) are introduced for use in
   P-DAO messages as a multihop alternative to the TIO, more in <xref target=
   'rplrpo'/>. One VIO is the stateful Storing-Mode VIO (SM-VIO); an SM-VIO
   installs a strict hop-by-hop P-Route called a Track Segment. The other is the
   Non-Storing Mode VIO (NSM-VIO); the NSM-VIO installs a loose source-routed
   P-Route called a Track Leg at the Track Ingress, which uses that state to
   encapsulate a packet IPv6_in_IPv6 with a new Routing Header (RH) to the Track
   Egress, more in <xref target= 'routing'/>.
   </t>
   <t>
   A P-DAO contains one or more RTOs to indicate the target (destinations) that
   can be reached via the P-Route, and at most one VIO that signals the sequence of nodes to be followed, more in <xref target= 'P-DAO'/>.
   In Non-Storing Mode, the Root sends the P-DAO to the Track Ingress where the source-routing state is stored, whereas in Storing Mode, the P-DAO is sent to the Track Egress and forwarded along the Segment in the reverse direction, installing a Storing Mode state to the Track Egress at each hop, see
   <xref target= 'nsP-DAO'/> and <xref target= 'sP-DAO'/> respectively.
   In both cases the Track Ingress is the owner of the Track, and it generates the P-DAO-ACK when the installation is successful.
   </t>

    </section> <!-- VIA Information OptionO -->
    <section anchor='extSIO'><name>Sibling Information Option</name>
   <t>
   This specification adds another CMO called the Sibling Information Option (SIO) that is used by a RPL Aware Node (RAN) to advertise a selection of its candidate neighbors as siblings to the Root, more in <xref target='rplsib'/>.
   The sibling selection process is out of scope. The expectation is that a node reports a Sibling Address in a SIO based on an active address registration <xref target="RFC8505"/> from that sibling for that address with the 'R' flag not set in the EARO. The node may assess the liveliness of the sibling at any time by performing a registration for one of its own addresses, either a link local or a global one, depending on whether the node expects the sibling to perform a matching advertisement in its own SIO.
   </t>

    </section> <!-- Sibling Information Option -->
    <section anchor='extPDR'><name>P-DAO Request</name>
   <t>
   Two new RPL Control Messages are also introduced, to enable a RAN
   to request the establishment of a Track between self as the Track Ingress
   Node and a Track Egress.
   The RAN makes its request by sending a new P-DAO Request (PDR) Message to
   the Root. The Root confirms with a new PDR-ACK message back to the requester
   RAN, see <xref target='P-DAOreq'/> for more.
   </t>
    </section><!-- P-DAO Request -->

    <section anchor='extRPI'><name>Extending the RPI</name>
         <t>
     Sending a Packet within a RPL Local Instance requires the presence of the abstract RPL Packet Information (RPI) described in section 11.2. of <xref target='RFC6550'/> in the outer IPv6 Header chain (see <xref target='RFC9008'/>). The RPI carries a local RPLInstanceID which, in association with either the source or the destination address in the IPv6 Header, indicates the RPL Instance that the packet follows.

    </t>
    <t>
    This specification extends <xref target='RFC6550'/> to create a new flag that signals that a packet is forwarded along a P-Route.

    </t>
    <dl>
       <dt> Projected-Route 'P':</dt><dd> 1-bit flag. It is set to 1 in the RPI
       that is added in the encapsulation when a packet is sent over a Track.
       It is set to 0 when a packet is forwarded along the main Track,
       including when the packet follows a Segment that joins loose hops
       of the main DODAG. The flag is not mutable en-route.</dd>
    </dl>
    <t>The encoding of the 'P' flag in native format is shown in <xref target='ext6553'/> while the compressed format is indicated in <xref target='ext8138'/>.
    </t>
    </section> <!-- Extending the RPI -->
  </section> <!-- Extending RFC 6550 -->


    <section anchor='ext6553'><name>Extending RFC 6553</name>
    <t>
    <xref target='RFC6553'>"The RPL Option for Carrying RPL Information in Data-Plane Datagrams"</xref>describes the RPL Option for use among RPL routers to include the abstract RPL Packet Information (RPI) described in section 11.2. of <xref target='RFC6550'/> in data packets.

    </t>    <t>

    The RPL Option is commonly referred to as the RPI though the RPI is really the abstract information that is transported in the RPL Option. <xref target='RFC9008'/> updated the Option Type from 0x63 to 0x23.

    </t>    <t>

    This specification modifies the RPL Option to encode the 'P' flag as follows:
    </t>
<figure anchor='Rpifmt'><name>Extended RPL Option Format</name>
              <artwork align="center">
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                |  Option Type  |  Opt Data Len |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|O|R|F|P|0|0|0|0| RPLInstanceID |          SenderRank           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         (sub-TLVs)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>Option Type:</dt><dd>0x23 or 0x63, see <xref target='RFC9008'/>
              </dd>
              <dt>Opt Data Len:</dt><dd> See <xref target='RFC6553'/>
              </dd>
              <dt>'O', 'R' and 'F' flags:</dt><dd> See <xref target='RFC6553'/>.
              Those flags MUST be set to 0 by the sender and ignored by the receiver if the 'P' flag is set.
              </dd>
              <dt> Projected-Route 'P':</dt><dd> 1-bit flag as defined in <xref target='extRPI'/>.
              </dd>
              <dt>RPLInstanceID:</dt><dd> See <xref target='RFC6553'/>. Indicates the TrackId if the 'P' flag is set, as discussed in <xref target='extP-DAO'/>.
              </dd>
              <dt>SenderRank:</dt><dd> See <xref target='RFC6553'/>. This
              field MUST be set to 0 by the sender and ignored by the receiver
              if the 'P'flag is set.
              </dd>

            </dl>

 </section> <!-- Extending RFC 6553 -->
 <section anchor='ext8138'><name>Extending RFC 8138</name>
    <t> The <xref target='RFC8138'>6LoWPAN Routing Header</xref> specification
    introduces a new IPv6 over Low-Power Wireless Personal Area Network
    (6LoWPAN) <xref target='RFC6282'/> dispatch type for use in 6LoWPAN
    route-over topologies, which initially covers the needs of RPL data packet
    compression.
    </t>
    <t>Section 4 of <xref target='RFC8138'/> presents the generic formats of
    the 6LoWPAN Routing Header (6LoRH) with two forms, one Elective that can
    be ignored and skipped when the router does not understand it, and one
    Critical which causes the packet to be dropped when the router cannot
    process it. The 'E' Flag in the 6LoRH indicates its form. In order to skip
    the Elective 6LoRHs, their format imposes a fixed expression of the size,
    whereas the size of a Critical 6LoRH may be signaled in variable forms to
    enable additional optimizations.
    </t>
    <t>When the <xref target='RFC8138'/> compression is used, the Root of the
    main DODAG can construct the compressed routing header (SRH-6LoRH) on
    behalf of the Track Root. The SRH-6LoRH is signaled in the NSM-VIO, to be
    placed in the packet encapsulation by the Track Ingress as is.
    </t>

    <t>Section 6.3 of <xref target='RFC8138'/> presents the formats of the
    6LoWPAN Routing Header of type 5 (RPI-6LoRH) that compresses the RPI for
    normal RPL operation. The format of the RPI-6LoRH is not suited for
    P-Routes since the O,R,F flags are not used and the Rank is unknown and
    ignored.
    </t><t>
    This specification introduces a new 6LoRH, the P-RPI-6LoRH that can be
    used in either Elective or Critical 6LoRH form,
    see <xref target='elec6lorhtbl'/> and <xref target='crit6lorhtbl'/>
    respectively. The new 6LoRH MUST be used as a Critical 6LoRH, unless an SRH-6LoRH is present and controls the routing decision, in which case it
    MAY be used in Elective form.
    </t>
    <t>
    The P-RPI-6LoRH is designed to compress the RPI along RPL P-Routes.
    Its format is as follows:
    </t>


<figure anchor='PRpifmt'><name>P-RPI-6LoRH Format</name>
              <artwork align="center">
     0                   1                   2
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |1|0|E| Length  |  6LoRH Type   | RPLInstanceID |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 </artwork>
</figure>
          <dl spacing='normal'>
              <dt> Type:</dt><dd> IANA is requested to define the same value of
              the type for both Elective and Critical forms. A type of 8 is suggested.
              </dd>
              <dt> Elective 'E':</dt><dd> See <xref target='RFC8138'/>. The 'E' flag is set to 1 to indicate an Elective 6LoRH, meaning that it can be ignored when forwarding.
              </dd>
              <dt> RPLInstanceID :</dt><dd> In the context of this specification, the RPLInstanceID field signals the TrackID, see <xref target='tracks'/> and <xref target='trkid'/> .
              </dd>

            </dl>

    </section> <!-- Extending RFC 8138 -->

  </section><!-- Extending existing RFCs  -->
    <section anchor='rplccmo'><name>New RPL Control Messages and Options</name>

    <section anchor='P-DAOreq'><name>New P-DAO Request Control Message</name>

               <t>
   The P-DAO Request (PDR) message is sent by a Node in the main DODAG to the
   Root. It is a request to establish or refresh a Track where this node is
   Track Ingress, and signals whether an acknowledgment called PDR-ACK is
   requested or not.  A positive PDR-ACK indicates that the Track was built
   and that the Roots commits to maintain the Track for the negotiated lifetime.
   </t>
   <t> The Root may use an asynchronous
   PDR-ACK with an negative status to indicate that the Track was terminated
   before its time. A status of "Transient Failure" (see <xref target=
   "iana-stats-rej"/>) is an indication that the PDR may be retried after a
   reasonable time that depends on the deployment. Other negative status
   values indicate a permanent error; the tentative must be abandoned until
   a corrective action is taken at the application layer or through network
   management.
   </t>
   <t>
   The source IPv6 address of the PDR signals the Track Ingress of the
   requested Track, and the TrackID is indicated in the message itself.
   One and only one RPL Target Option MUST be present in the message.
    The RTO signals the Track Egress, more in <xref target='req'/>.
    <!--
    TODO: A P-DAO parameter option MAY be present as well to provide additional
    information on the requested path.
    -->
    </t>
    <t>
    The RPL Control Code for the PDR is 0x09, to be confirmed by IANA.
    The format of PDR Base Object is as follows:
    </t>

<figure anchor='disupdfmt'><name>New P-DAO Request Format</name>
              <artwork align="center">
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |    TrackID    |K|R|   Flags   |  ReqLifetime  | PDRSequence   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   Option(s)...
 +-+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>TrackID:</dt><dd>8-bit field.
              In the context of this specification, the TrackID field signals the RPLInstanceID of the DODAG formed by the Track, see <xref target='tracks'/> and <xref target='trkid'/>. To allocate a
              new Track, the Ingress Node must provide a value that is not in
              use at this time.
              </dd>
              <dt>K:</dt><dd>The 'K' flag is set to indicate that the recipient
              is expected to send a PDR-ACK back.
              </dd>
              <dt>R:</dt><dd>The 'R' flag is set to request a Complex Track
              for redundancy.
              </dd>
              <dt>Flags:</dt><dd>Reserved. The Flags field MUST initialized to zero by the sender and MUST be ignored by the receiver
              </dd>
              <dt>ReqLifetime:</dt><dd> <t>8-bit unsigned integer.
              The requested lifetime for the Track expressed in Lifetime Units
              (obtained from the DODAG Configuration option).
              </t><t>
              A PDR with a fresher
              PDRSequence refreshes the lifetime, and a PDRLifetime of 0
              indicates that the Track should be destroyed, e.g., when the
              application that requested the Track terminates.
              </t>
              </dd>
              <dt>PDRSequence:</dt><dd>
              <t>8-bit wrapping sequence number,
              obeying the operation in section 7.2 of
              <xref target='RFC6550'/>.
              The PDRSequence is used to correlate a PDR-ACK message with the
              PDR message that triggered it. It is incremented at each PDR
              message and echoed in the PDR-ACK by the Root.
              </t>
              </dd>

            </dl>

    </section> <!-- New P-DAO Request Control Message -->

    <section anchor='rpldisackl'><name>New PDR-ACK Control Message</name>
    <t>
    The new PDR-ACK is sent as a response to a PDR message with the 'K' flag
    set.
    The RPL Control Code for the PDR-ACK is 0x0A, to be confirmed by IANA.
    Its format is as follows:
    </t>

<figure anchor='disackfmt'><name>New PDR-ACK Control Message Format</name>
              <artwork align="center">

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    TrackID    |     Flags     | Track Lifetime|  PDRSequence  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| PDR-ACK Status|                Reserved                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Option(s)...
+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>TrackID:</dt><dd>
             Set to the TrackID indicated in the TrackID field of the PDR
             messages that this replies to.
              </dd>

              <dt>Flags:</dt><dd>Reserved. The Flags field MUST initialized to zero by the sender and MUST be ignored by the receiver
              </dd>

              <dt>Track Lifetime:</dt><dd>
             Indicates that remaining Lifetime for the Track, expressed in
             Lifetime Units; the value of zero (0x00)
              indicates that the Track was destroyed or not created.
              </dd>

              <dt>PDRSequence:</dt><dd> 8-bit wrapping sequence number.
              It is incremented at each PDR message and echoed in the PDR-ACK.
              </dd>


              <dt>PDR-ACK Status:</dt><dd> <t>8-bit field indicating
            the completion.
            The PDR-ACK Status is substructured as indicated in <xref target='rpst'/>:</t>



 <figure anchor='rpst' suppress-title='false'><name>PDR-ACK status Format</name>
       <artwork align="center" name="" type="" alt="">
    0 1 2 3 4 5 6 7
   +-+-+-+-+-+-+-+-+
   |E|R|  Value    |
   +-+-+-+-+-+-+-+-+
</artwork>
 </figure>


    <dl  spacing='compact'>
	<dt>E:</dt><dd> 1-bit flag. Set to indicate a rejection. When not set, the value of 0
    indicates Success/Unqualified Acceptance and other values indicate "not an
    outright rejection".</dd>
	<dt>R:</dt><dd> 1-bit flag. Reserved, MUST be set to 0 by the sender and
    ignored by the receiver.</dd>
	<dt>Status Value:</dt><dd> 6-bit unsigned integer. Values depending on the
    setting of the 'E' flag, see
    <xref target='iana-ack-status'/> and <xref target='iana-nack-status'/>.
    </dd>

	</dl>

    </dd>

    <dt>Reserved:</dt><dd>The Reserved field MUST initialized to zero by the
    sender and MUST be ignored by the receiver
    </dd>

	</dl>

    </section> <!-- New PDR-ACK Control Message -->


     <section anchor='rplrpo'><name>Via Information Options</name>

    <t>A VIO signals the ordered list of IPv6 Via Addresses that constitutes
    the hops of either a Leg (using Non-Storing Mode) a Segment (using storing
    mode) of a Track.
    A VIO MUST contain at least one Via Address, and a Via Address MUST NOT be
    present more than once, which would create a loop. If one of these conditions happen, the VIO MUST be ignored and the P-DAO MUST be rejected
    with a Rejection Status of "Error in VIO", see <xref target='iana-stats-rpl-rej'/>.
    </t>
    <t>
    The format of the Via Information Options is as follows:
    </t>
<figure anchor='viao'><name>VIO format (uncompressed form)</name>
              <artwork align="center">
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type        | Option Length |     Flags     |   SegmentID   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |Segm. Sequence | Seg. Lifetime |      SRH-6LoRH header         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .                     Via Address 1                             .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .                              ....                             .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .                     Via Address n                             .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>Option Type:</dt><dd>0x0B for SM-VIO, 0x0C for NSM-VIO
                                     (to be confirmed by IANA)</dd>

              <dt>Option Length:</dt><dd>In bytes; variable, depending on the number of Via Addresses and the compression.</dd>


              <dt>SegmentID:</dt><dd>8-bit field that identifies a component
               of a Track or the main DODAG as indicated by the TrackID field.
               The value of 0 is used to signal a Serial Track, i.e., made of a
               single segment/Leg. In an SM-VIO, the SegmentID indicates an
               actual Segment. In an an NSM-VIO, it indicates a Leg, that is a
               serial subTrack that is added to the overall topology of the
               Track.
              </dd>

              <dt>Segment Sequence:</dt><dd>
              <t>8-bit unsigned integer.
              The Segment Sequence obeys the operation in section 7.2 of
              <xref target='RFC6550'/> and the lollipop starts at 255.
              </t><t>
              When the
              Root of the DODAG needs to refresh or update a Segment in a Track,
              it increments the Segment Sequence individually for that Segment.
              </t><t>
              The Segment information indicated in the VIO deprecates any state
              for the Segment indicated by the SegmentID within the indicated
              Track and sets up the new information.

              </t><t>
              A VIO with a Segment Sequence that is not as fresh as the current
              one is ignored.
              </t><t>
              A VIO for a given DODAGID with the same (TrackID,
              SegmentID, Segment Sequence) indicates a retry; it MUST NOT
              change the Segment and MUST be propagated or answered as the first
              copy.
              </t>
              </dd>

              <dt>Segment Lifetime:</dt><dd>
              <t>8-bit unsigned integer. The length
              of time in Lifetime Units (obtained from the Configuration
              option) that the Segment is usable.

              </t><t>
              The
              period starts when a new Segment Sequence is seen. The value of 255
              (0xFF) represents infinity. The value of zero (0x00)
              indicates a loss of reachability.

              </t><t>
              A P-DAO message that
              contains a VIO with a Segment Lifetime of
              zero is referred as a No-Path P-DAO in this document.
              </t>
              </dd>


              <dt>SRH-6LoRH header:</dt><dd>The first 2 bytes of the (first) SRH-6LoRH as shown in Figure 6 of <xref target='RFC8138'/>.
              A 6LoRH Type of 4 means that the VIA Addresses are provided in full with no compression.
              </dd>

              <dt>Via Address:</dt><dd>
              <t>An IPv6 address along the Segment. The VIO contains one or more addresses
              listed in the order of progression of the packet from Ingress to Egress.
              </t><t>
              In a No-Path Non-Storing Mode P-DAO, the list can be elided from
              the NSM-VIO since the state in the Ingress is erased whatever.
              In a Storing Mode P-DAO that updates or removes a section of an
              already existing Segment, the list in the SM-VIO may represent
              only the section of the Segment that is being updated; at the
              extreme, the SM-VIO updates only one node, in which case it
              contains only one IPv6 address.
              </t><t>
              For all other cases, the list in the VIO must be complete, with
              the strict sequence of hops in an SM-VIO and possibly a loose one
              in an NSM-VIO. In the case of an SM-VIO, the complete list indicates
              a sequential path through direct neighbors, from Segment Ingress to
              Egress, both included.
              In the case of an an NSM-VIO, the  list includes the Egress but not
              the Ingress node. It starts at the first hop and ends at a Track Egress
                </t><t>
              A non-Egress router that processes an SM-VIO from a MUST create a
              Storing Mode route associated with the Track towards the targets
              listed in the RPL Target Option via the node that sent the SM-VIO;
              it MAY also create additional routes towards the nodes after self
              in the list, but in case of memory shortage the routes to the
              targets have precedence since they are the ones that the router
              commits to store, and thenode may have to remove the additional
              routes to make room. A node that cannot store the routes to all
              the targets MUST reject the P-DAO by sending a DAO-ACK to the Root
              with a rejection status of "Out of Resources" as opposed to
              forwarding the DAO to its predecessor in the list. Other errors
              that prevent the installation of the route are reported with a
              status of "Unqualified Rejection".</t>
              <t>
              In the case of an NSM-VIO, the Ingress router that processes a new
              NSM-VIO MUST create a tunnel associated with the Track, and
              connected routes over the tunnel to the targets in the RTO.
              The tunnel encapsulation MUST incorporate a routing header via the
              list addresses listed in the VIO in the same order.
              The Track Egress MUST also be considered as an implicit target,
              so it MUST NOT be listed it in a RPL Target Option. The list in an
              NSM-VIO may be loose, provided that each listed node has a path to
              the next listed node, e.g., via a segment or another Track.
              </t><t>
              In the case of a SM-VIO, or if <xref target='RFC8138'/> is not used in the data packets, then the Root MUST use
              only one SRH-6LoRH per Via Information Option, and the compression is the same for
              all the addresses, as shown in <xref target='viao'/>.
              </t><t>
              In case of an NSM-VIO, and if <xref target='RFC8138'/> is in use in the main DODAG, then the Root SHOULD optimize the size of the NSM-VIO; more than one SRH-6LoRH may be present, e.g., if the compression level changes inside the Segment and different SRH-6LoRH Types are required. The content of the NSM-VIO starting at the first SRH-6LoRH header is thus verbatim the one that the Track Ingress places in the packet encapsulation to reach the Track Egress.

              </t>
              </dd>
            </dl>
    </section> <!-- Via Information Options -->
    <section anchor='rplsib'><name>Sibling Information Option</name>

    <t>
    The Sibling Information Option (SIO) provides indication on siblings that
    could be used by the Root to form P-Routes. One or more SIO(s) may be placed in the DAO messages that are sent to the Root in Non-Storing Mode.
    </t>
    <t>
    The format of the SIO is as follows:
    </t>
<figure anchor='siof'><name>Sibling Information Option Format</name>
              <artwork align="center">
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type        | Option Length |Comp.|B|D|Flags|    Opaque     |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |            Step of Rank       |          Reserved             |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .       Sibling DODAGID (if the D flag not set)               .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .                     Sibling Address                           .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 </artwork>
</figure>

          <dl spacing='normal'>
              <dt>Option Type:</dt><dd>0x0D (to be confirmed by IANA)</dd>

              <dt>Option Length:</dt><dd>In bytes, the size of the option.</dd>

              <dt>Compression Type:</dt><dd>3-bit unsigned integer. This is the
              SRH-6LoRH Type as defined in figure 7 in section 5.1 of
              <xref target='RFC8138'/> that corresponds to the compression used
              for the Sibling Address and its DODAGID if resent. The Compression
              reference is the Root of the main DODAG.
              </dd>
              <dt>Reserved for Flags:</dt><dd>MUST be set to zero by the sender
              and MUST be ignored by the receiver.
              </dd>
              <dt>B:</dt><dd>
              1-bit flag that is set to indicate that the connectivity to the sibling
              is bidirectional and roughly symmetrical. In that case, only one of the siblings may
              report the SIO for the hop. If 'B' is not set then the SIO only indicates connectivity
              from the sibling to this node, and does not provide information on the hop from this node
              to the sibling.

              </dd>
              <dt>D:</dt><dd>
              1-bit flag that is set to indicate that sibling belongs to the
              same DODAG. When not set, the Sibling DODAGID is indicated.

              </dd>

              <dt>Flags:</dt><dd>Reserved. The Flags field MUST initialized to zero by the sender and MUST be ignored by the receiver
              </dd>
              <dt>Opaque:</dt><dd>MAY be used to carry information that the node
              and the Root understand, e.g., a particular representation of the
              Link properties such as a proprietary Link Quality Information
              for packets received from the sibling. An industrial Alliance
              that uses RPL for a particular use / environment MAY redefine the
              use of this field to fit its needs.
              </dd>

              <dt>Step of Rank:</dt><dd>16-bit unsigned integer. This is the
              Step of Rank <xref target='RFC6550'/> as computed by the Objective
              Function between this node and the sibling.
              </dd>

              <dt>Reserved:</dt><dd>The Reserved field MUST initialized to zero
              by the sender and MUST be ignored by the receiver
              </dd>

              <dt>Sibling DODAGID:</dt><dd>2 to 16 bytes, the DODAGID of the
              sibling in a <xref target='RFC8138'/> compressed form as indicated
              by the Compression Type field. This field is present if and only
              if  the D flag is not set.
              </dd>
              <dt>Sibling Address:</dt><dd>2 to 16 bytes, an IPv6 Address of the
              sibling, with a scope that MUST be make it reachable from the Root,
              e.g., it cannot be a Link Local Address. The IPv6 address is
              encoded in the <xref target='RFC8138'/> compressed form
              indicated by the Compression Type field.
              </dd>
            </dl>               <t>
    An SIO MAY be immediately followed by a DAG Metric Container. In that case
    the DAG Metric Container provides additional metrics for the hop from the Sibling
    to this node.
    </t>
    </section> <!-- Sibling Information Option -->




    </section> <!-- New RPL Control Messages and Options -->



    <section anchor='P-DAO'><name>Projected Route Operations</name>

    <t>
    This draft adds a capability whereby the Root of a main RPL DODAG installs
    a Track as a collection of P-Routes, using a Projected-DAO (P-DAO) messages
    to maintain each individual route. The P-DAO signals a collection of
    Targets in the RPL Target Option(s) (RTO). Those Targets can be reached via
    a sequence of routers indicated in a VIO.
    A P-DAO message MUST contain at most one VIO, which is either a SM-VIO or an
    NSM-VIO, and which MUST follow one or more RTOs. There can be at most one
    such sequence of RTO(s) and a Via Information Option. A Track is identified
    by a tuple DODAGID, TrackID and each route within a Track is indexed by a
    SegmentID.
     </t> <t>
    A P-DAO MUST be sent from the address of the Root that serves as DODAGID for the main DODAG.
    A P-DAO that creates or updates a Track Leg MUST be sent to a GUA or a ULA
    of the Ingress of the Leg; it must contain the full list of hops in the
    Leg unless the Leg is being removed.
    A P-DAO that creates a new Track Segment MUST be sent to a GUA or a ULA
    of the Segment Egress and signal the full list of hops in Segment; a
    P-DAO that updates (including deletes) a section of a Segment MUST be
    sent to the first node after the modified Segment and signal the full
    list of hops in the section starting at the node that immediately
    precedes the modified section.
     </t> <t>
    If the 'K' Flag is present in the P-DAO, and unless the P-DAO does not
    reach it, the Ingress of the Leg, Segment, or updated section of the
    Segment, is the node that acknowledges the message, using a DAO-ACK that
    MUST be sent back to the address that serves as DODAGID for the main DODAG.
     </t> <t>
    Like a classical DAO message, a P-DAO causes a change of state only if it is
    "new" per section 9.2.2. "Generation of DAO Messages" of the <xref target='RFC6550'>
    RPL specification</xref>; this is determined using
    the Segment Sequence information from the VIO as opposed to the Path
    Sequence from a TIO. Also, a Segment Lifetime of 0 in a VIO indicates that the P-Route associated to the Segment is to be removed.
     </t> <t>
    There are two kinds of operation for the P-Routes, the Storing Mode
    and the Non-Storing Mode.
    </t><ul spacing='normal'>
     <li>
    The Non-Storing Mode is discussed in <xref target='nsP-DAO'/>. A Non-Storing
    Mode P-DAO carries an NSM-VIO with the loose list of Via Addresses that forms a
    source-routed Segment to the Track Egress. The recipient of the P-DAO is the
    Track Ingress; it MUST install a source-routed state to the Track Egress and reply to the Root directly using a DAO-ACK message if requested to.
     </li>
    <li>
    The Storing Mode is discussed in <xref target='sP-DAO'/>.  A Storing Mode
    P-DAO carries a SM-VIO with the strict list of Via Addresses from the Ingress to the Egress of the Segment in the data path order.
    The routers listed in the Via Addresses, except the Egress, MUST install a routing state to the Target(s) via the next Via Address in the SM-VIO.
    In normal operations, the P-DAO is propagated along the chain of Via Routers
    from the Egress router of the path till the Ingress one, which confirms the
    installation to the Root with a DAO-ACK message.
     </li>
     </ul>
    <t>In case of a forwarding error along a P-Route, an ICMPv6
    <xref target='RFC4443'/> error message is
    sent to the Root with a new Code "Error in P-Route"
    (See <xref target='ICMPv6ErrPRoute'/>).
    The Root can then repair by updating the broken Segment and/or Tracks, and
    in the case of a broken Segment, remove the leftover sections of the segment
    using SM-VIOs with a lifetime of 0 indicating the section ot one or more
    nodes being removed (See <xref target='maintain'/>).
       </t> <t>
    The portion of the invoking packet that is sent back in the ICMP message
    SHOULD record at least up to the RH if one is present, and this hop of the
    RH SHOULD be consumed by this node so that the destination in
    the IPv6 header is the next hop that this node could not reach.
    if a 6LoWPAN Routing Header (6LoRH) <xref target='RFC8138'/> is used to
    carry the IPv6 routing information in the outer header then that whole
    6LoRH information SHOULD be present in the ICMP message.
       </t> <t>
    The sender and exact operation depend on the Mode and is described in
    <xref target='nsP-DAO'/> and <xref target='sP-DAO'/> respectively.
    </t>
    <!--t>
    Note: The Target of a route that is installed by a P-DAO is not necessarily
    inside the DODAG, though how the Root and the optional PCE obtain the
    additional topological information to compute other routes is out of scope
    for this document.
    </t-->

      <section anchor='req'><name>Requesting a Track</name>

      <t>
      A Node is free to ask the Root for a new Track for which it will be Ingress at any time.
      This is done with a PDR message, that indicates the desired TrackID and the duration for which the Track should be established. Upon a PDR, the Root MAY install the necessary Segments, in which case it answers with a PDR-ACK indicating the granted Track Lifetime.
      All the Segments MUST be of a same mode, either Storing or Non-Storing.
      All the Segments MUST be created with the same TrackID and the same DODAGID signaled in the P-DAO.
      </t>
      <t>
      The Root is free to design the Track as it wishes, and to change the Segments overtime to serve the Track as needed, without notifying the
      resquesting Node.
      The Segment Lifetime in the P-DAO messages does not need to be aligned to
      the Requested Lifetime in the PDR, or between P-DAO messages for different Segments. The Root may use shorter lifetimes for the Segments
      and renew them faster than the Track is, or longer lifetimes in which case it will need to tear down the Segments if the Track is not renewed.
      </t>
      <t>
      When the Track Lifetime that was returned in the PDR-ACK is close to elapse, the resquesting Node needs to resend a PDR using the TrackID in the PDR-ACK to extend the lifetime of the Track, else the Track will time out and the Root will tear down the whole structure.
      </t>
      <t>
      If the Track fails and cannot be restored, the
      Root notifies the resquesting Node asynchronously with a PDR-ACK
      with a Track Lifetime of 0, indicating that the Track has failed, and
      a PDR-ACK Status indicating the reason of the fault.
      </t>
      </section><!-- Requesting a Track  -->


     <section anchor='trkid'><name>Identifying a Track</name>

     <t>
     RPL defines the concept of an Instance to signal an individual
     routing topology but does not have a concept of an administrative
     distance, which exists in certain proprietary implementations to sort out
     conflicts between multiple sources of routing information within one
     routing topology.
     </t>
     <t>
     This draft leverages the RPL Instance model as follows:
     </t><ul spacing='normal'>
     <li>
     <t>
     The Root MAY use P-DAO messages to add better routes in the main (Global)
     Instance in conformance with the routing objectives in that Instance.
     To achieve this, the Root MAY install an Storing-Mode P-Route along a path down the main Non-Storing Mode DODAG. This enables a loose source routing and reduces the size of the Routing Header, see <xref target='loose'/>.
     </t>
     <t>
     When adding an Storing-Mode P-Route to the main RPL Instance, the Root MUST set the RPLInstanceID field of the P-DAO message (see section 6.4.1. of <xref target='RFC6550'/>) to the RPLInstanceID of the main DODAG, and MUST NOT use the DODAGID field. A P-Route provides a longer match to the Target Address than the default route via the Root, so it is preferred.
     </t>
     <t>
     Once the P-Route is installed, the intermediate nodes listed in the SM-VIO after first one (i.e. The Ingress) can be elided from the RH in packets sent along the Segment signaled in the P-DAO. The resulting loose source routing header indicates (one of) the Target(s) as the next entry after the Ingress.

     </t>
     </li>
     <li>
     <t>
     The Root MAY also use P-DAO messages to install a specific (say, Traffic Engineered) path as a single Segment, a single Track Leg with multiple segments, or a more complex structure, to a particular endpoint that is the Track Egress. In that case, the Root MUST install a Local RPL Instance (see section 5 of <xref target='RFC6550'/>), and the Local RPLInstanceID is used as TrackID.
          </t>
     <t>
     In that case, the TrackID MUST be unique for the Global Unique IPv6 Address (GUA) or Unique-Local Address (ULA) of the Track Ingress that serves as DODAGID for the Track. The Track Ingress owns the namespace of its TrackIDs, so it can pick any unused value to request a new Track with a PDR. The Root is aware of all the active Tracks, so it can also pick any unused value to form Tracks without a PDR. To avoid a collision of the Root and the Track Ingress picking the same value at the same time, it is RECOMMENDED that the Track Ingress starts allocating the ID value of the Local RPLInstanceID (see section 5.1. of <xref target='RFC6550'/>) used as TrackIDs with the value 0 incrementing, while the Root starts with 63 decrementing.

     </t>
     <t>
     This way, a Track is uniquely identified by the tuple (DODAGID, TrackID) where the TrackID is always represented with the D flag set to 0.
     </t>
     <t>
     The Track Egress Address and the TrackID MUST be signaled in the P-DAO message as shown in <xref target='p-dao-fmt'/>.
     </t>

     </li>


     </ul>
     </section><!-- Identifying a Track -->

      <section anchor='inst'><name>Installing a Track</name>

   <t>
   A Storing-Mode P-DAO contains an SM-VIO that signals the strict sequence of consecutive nodes to form a segment between a segment Ingress and a segment Egress (both included). It installs a route of a higher precedence along the segment towards the Targets indicated in the Target Options. The segment is included in a DODAG indicated by the P-DAO Base Object, that may be the one formed by the main RPL Instance, or a Track associated with a local RPL Instance. A Track Egress is signaled as a Target in the P-DAO, and as the last entry is an SM-VIO of a last segment towards that Egress.
   </t>
   <t>
   A Non-Storing-Mode P-DAO signals a strict or loose sequence of nodes between the Track Ingress (excluded) and a Track Egress (included). It installs a source-routed path of a higher precedence within the Track indicated by the P-DAO Base Object, towards the Targets indicated in the Target Options. The source-routed path requires a Source-Routing header which implies an encapsulation to add the SRH to an existing packet.
   In order to avoid fragmentation, e.g., using <xref target='RFC4944'/>,
   <xref target='RFC8930'/>, and/or <xref target='RFC8931'/> in a 6LoWPAN LLN,
   it is RECOMMENDED to allow an MTU that is larger than 1280 in the main
   DODAG and allows for the additional headers while exposing only 1280 to the
   6LoWPAN Nodes as indicated by section 4 of <xref target='RFC4944'/>.
   </t>
   <t>
   The next entry in the sequence must be either a neighbor of the previous entry, or reachable as a Target via another P-Route, either Storing or Non-Storing.
   If it is reachable over a Storing Mode P-Route, the next entry in the loose sequence is the Target of a previous segment and the Ingress of a next segment; the segments are associated with the same Track, which avoids the need of an encapsulation.
   Conversely, if it is reachable over a Non-Storing Mode P-Route, the  next loose source routed hop of the inner Track is a Target of a previous Track and the Ingress of a next Track, which requires a de- and a re-encapsulation.
  </t>
 <t>
   A Serial Track can be installed by a single P-Routes that signals the sequence of consecutive nodes, either in Storing Mode as a single-Segment Track, or in Non-Storing Mode as a single-Leg Track. A a single Leg Track can be installed as a loose Non-Storing Mode P-Route, in which case the next loose entry must recursively be reached over a Serial Track.
   This is why a Segment of a Track MUST be installed before the Leg(s) that use it.
   </t>
   <t>
   A Complex Track can be installed as a collection of P-Routes with the same DODAGID and Track ID. The Ingress of a Non-Storing Mode P-Route is the owner and Root of the DODAGID. The Ingress of a Storing Mode P-Route must be either the owner of the DODAGID, or a hop of a Leg of the same Track. In the latter case, the Targets of the P-Route must include the next hop of the Leg if there is one, to ensure forwarding continuity.
   In the case of a Complex Track, each Segment is maintained independently and
   asynchronously by the Root, with its own lifetime that may be shorter, the
   same, or longer than that of the Track.
   </t>

    <section anchor='sP-DAO'><name>Installing a Track Segment with a Storing-Mode P-Route</name>
    <!--
    Profile 1 extends RPL operation in a Non-Storing Mode network with
    Storing-Mode P-Routes that install Segments along the main DODAG
    and enable to loose source routing  between the Root and the targets.
   -->

    <t>
    As illustrated in <xref target='sdf'/>, a P-DAO that carries a SM-VIO
    enables the Root to install a stateful route towards a collection of Targets
    along a Segment between a Track Ingress and a Track Egress using a
    projected DAO Message.

    </t>

      <figure anchor='sdf'><name>Projecting a route</name>
        <artwork>
        ------+---------
              |          Internet
              |
           +-----+
           |     | Border Router
           |     |  (RPL Root)
           +-----+                      |     ^                   |
              |                         | DAO | ACK               |
        o    o   o    o                 |     |                   |
    o o   o  o   o  o  o o   o          |  ^       | Projected    .
   o  o o  o o    o   o   o  o  o       |  | DAO   | Route        .
   o   o    o  o     o  o    o  o  o    | ^        |              .
  o  o   o  o   o         o   o o       v | DAO    v              .
  o          o   LLN   o   o     o                                |
      o o   o        o     o              Loose Source Route Path |
   o       o      o    o                 From Root To Destination v
    </artwork>
         </figure>


    <t>
     In order to install the relevant routing state along the Segment ,
     the Root sends a unicast P-DAO message to the Track Egress router of the routing Segment that is being installed. The P-DAO message contains a SM-VIO with the direct sequence of Via Addresses. The SM-VIO follows
     one or more RTOs indicating the Targets to which the Track leads. The SM-VIO contains a Segment Lifetime for which the state is to be maintained.
     </t><t>
     The Root sends the P-DAO directly to the Egress node of the Segment.
     In that P-DAO, the destination IP address matches the last Via Address in the SM-VIO. This is how the Egress recognizes its role. In a similar fashion,
     the Ingress node recognizes its role as it matches first Via Address in the SM-VIO.
     </t><t>
     The Egress node of the Segment is the only node in the path that does not
     install a route in response to the P-DAO; it is expected to be already able
     to route to the Target(s) on its own.
     If one of the Targets is not known, the node MUST answer to the Root
     with a negative DAO-ACK listing the Target(s) that could not be located
     (suggested status 10 to be confirmed by IANA).
    </t><t>
     If the Egress node can reach all the Targets, then it forwards the P-DAO
     with unchanged content to its loose predecessor in the Segment as indicated
     in the list of Via Information options, and recursively the message is propagated
     unchanged along the sequence of routers indicated in the P-DAO, but in the
     reverse order, from Egress to Ingress.
     </t><t>

     The address of the predecessor to be used as destination of the propagated
     DAO message is found in the Via Address the precedes the one
     that contain the address of the propagating node, which is used as source
     of the message.

    </t><t>
     Upon receiving a propagated DAO, all except the Egress Router MUST install a route towards the DAO Target(s) via their successor in the SM-VIO. The router MAY install additional routes towards the
     VIA Addresses that are the SM-VIO after the next one, if any, but
     in case of a conflict or a lack of resource, the route(s) to the Target(s) have precedence.
     </t>
     <t>
     If a router cannot reach its predecessor in the SM-VIO,
     the router MUST answer to the Root with a negative DAO-ACK
     indicating the successor that is unreachable
     (suggested status 11 to be confirmed by IANA).
    </t>
    <t>
     The process continues till the P-DAO is propagated to Ingress router of
     the Segment, which answers with a DAO-ACK to the Root. The Root always
     expects a DAO-ACK, either from the Track Ingress with a positive status
     or from any node along the segment with a negative status. If the DAO-ACK
     is not received, the Root may retry the DAO with the same TID, or tear
     down the route.
    </t>

    </section>  <!-- Installing a Track Segment with a Storing-Mode P-Route -->





    <section anchor='nsP-DAO'><name>Installing a Track Leg with a Non-Storing Mode P-Route</name>

    <t>
    As illustrated in <xref target='nsdf'/>, a P-DAO that carries an NSM-VIO
    enables the Root to install a source-routed path from a Track Ingress towards
    a Target along the main DODAG.
    </t>

          <figure anchor='nsdf'><name>Projecting a Non-Storing Route</name>
            <artwork>
           ------+---------
                 |          Internet
                 |
              +-----+
              |     | Border Router
              |     |  (RPL Root)
              +-----+                    |  P  ^ ACK
                 |        Track          | DAO |
           o    o   o  o  Ingress X      V     |   X
       o o   o  o   o  o     o   X   o             X Source
      o  o o  o o    o   o  o    X  o  o           X Routed
      o   o    °  o     o   o   o X     o          X Segment
     o  o   o  o   o  o    o  o     X Track        X
        o  o  o  o             o     Egress

       o       o               o    o
     o          o             o     o
                                   destination

                       LLN
                       </artwork>
          </figure>
    <!--t>
    A route indicated by an NSM-VIO may be loose, meaning that the node that owns
    the next listed Via Address is not necessarily a neighbor. Without proper
    loop avoidance mechanisms, the interaction of loose source routing and other
    mechanisms may effectively cause loops.

    </t-->
    <t>

      When forwarding a packet to a destination for which the router determines
      that routing happens via a Track Target, the router inserts the Source
      Routing Header in the packet with the final destination at the Track Egress.
    </t>
    <t>
      In order to signal the Segment, the router encapsulates the
      packet with an IP-in-IP header and a Routing Header as follows:
    </t>
    <ul>
    <li>
      In the uncompressed form the source of the packet is this router, the
      destination is the first Via Address in the NSM-VIO, and the RH is a
      Source Routing Header (SRH) <xref target='RFC6554'/> that contains the
      list of the remaining Via Addresses terminating by the Track Egress.
    </li>
    <li>
    <t>
    The preferred alternate in a network where 6LoWPAN Header Compression
    <xref target='RFC6282'/> is used is to leverage <xref target='RFC8025'>
    "IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging
    Dispatch"</xref> to compress the RPL artifacts as indicated in
    <xref target='RFC8138'/>.
    </t>
    <t>
    In that case, the source routed header is the exact copy of the (chain of) SRH-6LoRH found in the NSM-VIO, also terminating by the Track Egress.
    The RPI-6LoRH is appended next, followed by an IP-in-IP 6LoRH Header  that indicates the Ingress Router in the Encapsulator Address field, see as a similar case Figure 20 of <xref target='RFC9035'/>.

    </t>
    </li>
    </ul>
    <t>
      In the case of a loose source-routed path, there MUST be a segment
      for the same Track to the loose next hop, on which case the packet is
      forwarded to the next hop along that segment, or a common neighbor with the
      loose next hop, on which case the packet is forwarded to that neighbor, or
      another Track to the loose next hop for which this node or a neighbor is
      Ingress; in the last case, another encapsulation takes place and the
      process possibly recurses; otherwise the packet is dropped.
     </t>
      <t>In case of a forwarding error along a Source Route path, the node that
      fails to forward SHOULD send an ICMP error with a code "Error in Source
      Routing Header" back to the source of the packet, as described in section
      11.2.2.3. of <xref target='RFC6550'/>. Upon this message, the
      encapsulating node SHOULD stop using the source route path for a period
      of time and it SHOULD send an ICMP message with a Code "Error in
      P-Route" to the Root. Failure to follow these steps may result
      in packet loss and wasted resources along the source route path that
      is broken.
      </t>
  </section> <!-- Installing a Track Segment with a Storing-Mode P-Route -->

      </section><!-- Installing a Track  -->


    <section anchor='teardown'><name>Tearing Down a P-Route</name>
    <t>
    A P-DAO with a lifetime of 0 is interpreted as a No-Path DAO and results in
    cleaning up existing state as opposed to refreshing an existing one or
    installing a new one. To tear down a Track, the Root must tear down all the
    Track Segments and Legs that compose it one by one.
    </t>
    <t>
    The Root cleans up a Leg of a Track in the Ingress node by sending an NSM-VIO
    to the Ingress with the TrackID and the SegmentID of the Leg being removed,
    a Segment Lifetime of 0 and a newer Segment Sequence. Since the state is
    located only the Ingress Node, it is simply removed; the SRH-6LoRH and the
    Via Addresses of the NSM-VIO are not needed and can be omitted.
    </t>
    <t>
    The Root cleans up a section of a Segment by sending an SM-VIO to the last
    node of the Segment, with the TrackID and the SegmentID of the Segment being
    updated, a Segment Lifetime of 0 and a newer Segment Sequence.
    The Via Addresses in the SM-VIO indicates the section of the Segment being
    modified, from the first to the last node that is impacted. This can be the
    whole Segment if it is totally removed, or a sequence of one or more nodes
    that have been bypassed by a Segment update.
    </t>
    <t>
    The No-Path P-DAO is forwarded normally along the reverse list, even if the
    intermediate node does not find a Segment state to clean up. This results in
    cleaning up the existing Segment state if any, as opposed to refreshing an
    existing one or installing a new one.
    </t>
    </section><!-- Tearing Down a P-Route -->

     <section anchor='maintain'><name> Maintaining a Track</name>
     <t>
     Repathing a Track Segment or Leg may cause jitter and packet misordering.
     For critical flows that require timely and/or
     in-order delivery, it might be necessary to deploy the PAREO functions
     <xref target='I-D.ietf-raw-architecture'/> over a highly redundant Track..
     This specification allows to use more than one Leg for a Track, and 1+N
     packet redundancy.
     </t>
    <t>
     This section provides the steps to ensure that no packet is lost due to
     the operation itself.
     This is ensured by installing the new section from its last node to the
     first, so when an intermediate node installs a route along the new section,
     all the downstream nodes in the section have already installed their own.
     The disabled section is removed when the packets in-flight are forwarded
     along the new section as well.
     </t>
    <section anchor='maintainS'><name>Maintaining a Track Segment</name>

    <t>
    To modify a section of a Segment between a first node and a second, downstream
    node (which can be the Ingress and Egress), while conserving those nodes
    in the Segment, the Root sends an SM-VIO to the second node indicating the
    sequence of nodes in the new section of the Segment. The SM-VIO indicates
    the TrackID and the SegmentID of the Segment being updated, and a newer
    Segment Sequence. The P-DAO is propagated from the second to the first node
    and on the way, it updates the state on the nodes that are common to the old
    and the new section of the Segment and creates a state in the new nodes.
    </t>
    <t>
    When the state is updated in an intermediate node, that node might still
    receive packets that were in flight from the Ingress to self over the
    old section of the Segment. Since the remainder of the Segment is already
    updated, the packets are forwarded along the new version of the Segment from
    that node on.
    </t>
    <t>
    After a reasonable time to enable the deprecated sections to empty, the root
    tears down the remaining section(s) of the old segments are teared down as
    described in <xref target='teardown'/>.
    </t>
    </section>  <!-- Maintaining a Track Segment -->

    <section anchor='maintainT'><name>Maintaining a Track Leg</name>

     <t>This specification allows to add Legs to a Track by sending
     a Non-Storing Mode P-DAO to the Ingress associated to the same TrackID,
     and a new Segment ID. If the Leg is loose, then the Segments that join
     the hops must be created first.  It makes
     sense to add a new Leg before removing one that is misbehaving, and switch
     to the new Leg before removing the old.
     </t>
     <t>
     It is also possible to update a Track Leg by sending a Non-Storing Mode
     P-DAO to the Ingress with the same Segment ID, an incremented Segment
     Sequence, and the new complete listy of hops in the NSM-VIO.
     Updating a live Leg means changing one or more of the intermediate loose
     hops, and involves laying out new Segments from and to the new loose hops
     before the NSM-VIO for the new Leg is issued.
     </t>
    <t>
    Packets that are in flight over the old version of the Track Leg still
    follow the old source route path over the old Segments.
    After a reasonable time to enable the deprecated Segments to empty, the root
    tears down those Segments as described in <xref target='teardown'/>.
    </t>
    </section>  <!-- Maintaining a Track Leg -->

    </section> <!-- Maintaining a Track -->



     <section anchor='routing'><name>Forwarding Along a Track</name>

     <t>
     This draft leverages the RPL Forwarding model follows:
     </t><ul spacing='normal'>
     <li>
      <t>
     In the data packets, the Track DODAGID and the TrackID MUST be respectively signaled as the IPv6 Source Address and the RPLInstanceID field of the RPI that MUST be placed in the outer chain of IPv6 Headers.
      </t>
     <t>
     The RPI carries a local RPLInstanceID called the TrackID, which, in association with the DODAGID, indicates the Track along which the packet is forwarded.
      </t>
     <t>
     The D flag in the RPLInstanceID MUST be set to 0 to indicate that the source address in the IPv6 header is set ot the DODAGID, more
     in <xref target='routing'/>.

     </t>


     </li>
     <li>
      <t>
      This draft conforms the principles of
      <xref target='RFC9008'/> with regards to packet
      forwarding and encapsulation along a Track.
      </t>
      <ul>
      <li>
      In that case,
      the Track is the DODAG, the Track Ingress is the Root, and the Track Egress
      is a RAL, and neighbors of the Track Egress that can be reached via the Track are RULs. The encapsulation rules in  <xref target='RFC9008'/> apply.
      </li><li>
      If the Track Ingress is the originator of the packet and the Track Egress
      is the destination of the packet, there is no need for an encapsulation.
      </li><li>
      So the Track Ingress must encapsulate the traffic that it did not originate, and add an RPI in any fashion.
      </li>
      </ul>
     <t>
     A packet that is being routed over the RPL Instance associated to a first  Non-Storing Mode Track MAY be placed (encapsulated) in a second Track to cover one loose hop of the first Track.
     On the other hand, a Storing Mode Track must be strict and a packet that
     it placed in a Storing Mode Track MUST follow that Track till the Track Egress.
     </t>
     <t>
      When a Track Egress extracts a packet from a Track (decapsulates the packet), the Destination of the inner packet MUST be either this node or a direct neighbor, or a Target of another Segment of the same Track for which this node is Ingress, otherwise the packet MUST be dropped.

     </t>
     <!-- TODO: add config parm to the local Instance -->
     </li>
     </ul>
    <t>
     All properties of a Track operations are inherited form the main RPL Instance
     that is used to install the Track. For instance, the use of compression per
     <xref target='RFC8138'/> is determined by whether it is used in the main
     instance, e.g., by setting the "T" flag
     <xref target='RFC9035'/> in the RPL
     configuration option.
   </t>
    </section><!-- Forwarding along a Track -->

    </section><!-- Projected Route Operations -->

    <section anchor='prof'><name>Profiles</name>
    <t>
    This document provides a set of tools that may or may not be needed by
    an implementation depending on the type of application it serves.
    This sections described profiles that can be implemented separately and
    can be used to discriminate what an implementation can and cannot do.
    </t>

    <dl>
    <dt> Profile 0 </dt><dd>
      Profile 0 is the Legacy support of <xref target='RFC6550'/> Non-Storing
      Mode. It provides the minimal common functionality that must be
      implemented as a prerequisite to all the Track-supporting profiles.
      The other Profiles extend Profile 0 with selected capabilities that this
      specification introduces on top.
    </dd>
    <dt> Profile 1 (Storing-Mode P-Route Segments along the main DODAG) </dt><dd>
      Profile 1 does not
      create new paths; it combines Storing and Non-Storing Modes to balance the
      size of the routing header in the packet and the amount of state in the
      intermediate routers in a Non-Storing Mode RPL DODAG.
    </dd>
    <dt> Profile 2 (Non-Storing-Mode P-Route Segments along the main DODAG)</dt><dd>
      Profile 2 extends Profile 0 with Strict Source-Routing Non-Storing-Mode P-Routes along the main DODAG. Profile 2 provides the same capability to compress the SRH in packets down the main DODAG as Profile 1, but it require an encapsulation, in order to insert an additional SRH between the loose source routing hops.
    </dd>
    <dt> Profile 3 </dt><dd>
      Profile 3 and above
      build Tracks that do not necessarily follow the main DODAG. In order to
      form the best path possible, those Profiles require the support of
      Sibling Information Option to inform the Root of additional possible hops.
      Profile 3 extends Profile 1 with additional Storing-Mode P-Routes
      that install segments that do not follow the main DODAG.
      If the Segment Ingress (in the SM-VIO) is the same as the IPv6 Address of
      the Track Ingress (in the projected DAO base Object), the P-DAO creates an
      implicit Track between the Segment Ingress and the Segment Egress.
      </dd>
    <dt> Profile 4 </dt><dd>
      Profile 4 extends Profile 2 with Strict Source-Routing Non-Storing-Mode P-Routes to form Tracks inside the main DODAG. A Track is formed
      as one or more strict source source routed paths between the Root that
      is the Track Ingress, and the Track Egress that is the last node

    </dd>
    <dt> Profile 5 </dt><dd>
      Profile 5 Combines Profile 4 with Profile 1 and enables to loose source
      routing between the Ingress and the Egress of the Track. As in Profile 1,
      Storing-Mode P-Routes connect the dots in the loose source route.
    </dd>
    <dt> Profile 6 </dt><dd>
      Profile 6 Combines Profile 4 with Profile 2 and also enables to loose
      source routing between the Ingress and the Egress of the Track.

    </dd>
    </dl>


    </section><!-- Profiles -->



    <section><name>Storing-Mode Main DODAG</name>

<t>This specification expects that the main DODAG is operated in Non-Storing
   Mode. The reasons for that limitation are mostlt related to LLN operations,
   power and spectrum conservation:</t>
   <ul>
   <li>In Non-Storing Mode The Root already possesses the DODAG topology, so the
   additional topological information is reduced to the siblings.
   </li>
   <li>The downwards routes are updated with unicast messages to the Root, which
   ensures that the Root can reach back to the LLN nodes after a repair faster
   than in the case of Storing Mode. Also the Root can control the use of the
   path diversity in the DODAG to reach to the LLN nodes. For both reasons,
   Non-Storing Mode provides better capabilities for the Root to maintain the
   P-Routes.
   </li>
   <li>
   When the main DODAG is operated in Non-Storing Mode, P-Routes enable
   loose Source Routing, which is only an advantage in that mode. Storing Mode
   does not use Routing Headers, and does not benefit from this capability.
   </li>
   </ul>

<t>On the other hand, since RPL is a Layer-3 protocol, its applicability
   extends beyond LLNs, e.g., on wired networks, as used by the ANIMA ACP <xref target='RFC8994'/>. In a powered and wired network,
   where the memory to store the needed routes is easily available, Storing
   Mode usually makes more sense than Non-Storing as i reduces the route stretch
   and lowers the load on the Root. In that case, the control path between the
   Root and the LLN nodes is highly available compared to LLNs, and the nodes
   can be reached to maintain the P-Routes at most times. This section specifies the additions that are needed in Storing Mode.
   </t>


<t>In Storing Mode, the Root misses the Child to Parent relationship that forms
   the main DODAG, as well as the sibling information. To provide that knowledge
   the nodes in the network MUST send additional DAO messages that are unicast
   to the Root as Non-Storing DAO messages are.
   </t>

<t>In the DAO message, the originating router advertises a set of neighbor
   nodes using Sibling Information Options, regardless of the relative position
   in the DODAG of the advertised node vs. this router.
   To advertise a neighbor node, the router MUST have an active Address
   Registration from that node using <xref target='RFC8505'/>, for an address
   (ULA or GUA) that serves as identifier for the node.
   </t>

<t>The DAO message MUST be formed as follows:
   </t>
   <ul>
   <li>
   The originating router is identified by the source address of the DAO. That
   address MUST be the one that this router registers to neighbor routers
   so the Root can correlate the DAOs from those routers when they advertise
   this router as their neighbor. The DAO contains one or more sequences of one
   Transit Information Option and one or more Sibling Information Options.
   There is no RPL Target Option so the Root is not confused into adding a
   Storing Mode Router to the target.
   </li>
   <li>
   The TIO is formed as in Storing Mode, and the Parent Address is not present.
   The Path Sequence and Path Lifetime fields
   are aligned with the values used in the Address Registration of the node(s) advertised in the SIO, as explained in Section 9.1. of
   <xref target='RFC9010'/>.
   Having similar values in all  nodes allows to factorise the TIO for multiple
   SIOs as done with <xref target='RFC6550'/>.
   </li>
   <!--
   <li>
   The TIO is followed by one RPL Target Option that signals the router that
   sends the information.  The Target Prefix in the RTO contains the address in
   full and the "Advertiser address in Full" (F) <xref target='RFC9010'/> flag
   is set to 1.
   TODO Flag to indicate not to install a DAO route to Target?
   </li>
   -->
   <li>The TIO is followed by one or more SIOs that provide an address (ULA or GUA) of the advertised neighbor node.
   </li>
   </ul>

</section><!-- Storing-Mode Main DODAG -->



    <section><name>Security Considerations</name>


     <t>
   It is worth noting that with <xref target='RFC6550'/>, every
   node in the LLN is RPL-aware and can inject any RPL-based attack in the
   network. This draft uses messages that are already present in RPL
   <xref target='RFC6550'/> with optional secured versions. The same secured
   versions may be used with this draft, and whatever security is deployed for
     a given network also applies to the flows in this draft.

 </t>
 <t>
	The LLN nodes depend on the 6LBR and the RPL participants for their
    operation.
	A trust model must be put in place to ensure that the right devices are
	acting in these roles, so as to avoid threats such as black-holing,
    (see <xref target='RFC7416'/> section 7). This trust model could be
    at a minimum based on a Layer-2 Secure joining and the Link-Layer security.
    This is a generic 6LoWPAN requirement, see Req5.1 in Appendix B.5 of <xref target='RFC8505'/>.
 </t><t>
    In a general manner, the Security Considerations in <xref target='RFC6550'/>,
    and <xref target='RFC7416'/> apply to this specification as well.
    The Link-Layer security is needed in particular to prevent
    Denial-Of-Service attacks whereby a rogue router creates a high churn in the
    RPL network by constantly injected forged P-DAO messages and using up all
    the available storage in the attacked routers.

 </t> <t>
    Additionally, the trust model could include a role validation (e.g., using a
    role-based authorization) to ensure that the node that
    claims to be a RPL Root is entitled to do so. That trust should propagate
    from Egress to Ingress in the case of a Storing Mode P-DAO.

	</t>


</section>
<section anchor='IANAcon'><name>IANA Considerations</name>


   <section anchor='elec6lorh'><name>New Elective 6LoWPAN Routing Header Type</name>

   <t>  This document updates the IANA registry titled "Elective 6LoWPAN
   Routing Header Type" that was created for <xref target='RFC8138'/>  and assigns the following value:
</t>
        <table anchor="elec6lorhtbl"><name>New Elective 6LoWPAN Routing Header Type</name>
   <thead>

          <tr><th align='center'>Value</th>

          <th align='left'>Description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>8</td>

          <td align='left'>P-RPI-6LoRH</td>

          <td align='left'>This document</td></tr>

    </tbody>
        </table>
   </section><!-- New Elective 6LoWPAN Routing Header Type -->


   <section anchor='crit6lorh'><name>New Critical 6LoWPAN Routing Header Type</name>
   <t>  This document updates the IANA registry titled "Critical 6LoWPAN
   Routing Header Type" that was created for <xref target='RFC8138'/>  and assigns the following value:
</t>
        <table anchor="crit6lorhtbl"><name>New Critical 6LoWPAN Routing Header Type</name>
   <thead>

          <tr><th align='center'>Value</th>

          <th align='left'>Description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>8</td>

          <td align='left'>P-RPI-6LoRH</td>

          <td align='left'>This document</td></tr>

    </tbody>
        </table>
   </section><!-- New Critical 6LoWPAN Routing Header Type -->




   <section anchor='RPIIANA'><name>New Subregistry For The RPL Option Flags</name>
    <t>
   IANA is required to create a subregistry for the 8-bit RPL Option Flags field, as detailed in <xref target='Rpifmt'/>, under the "Routing Protocol for Low Power and Lossy Networks (RPL)" registry. The bits are indexed from 0 (leftmost) to 7. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Indication When Set</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>. The initial allocation is as indicated in <xref target='RPLPDRflagRegtbl'/>:
 </t>

        <table anchor="RPLoptFlagtbl"><name>Initial PDR Flags</name>
   <thead>

          <tr><th align='center'>Bit number</th>

          <th align='left'>Indication When Set</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0</td>

          <td align='left'>Down 'O'</td>

          <td align='left'><xref target='RFC6553'/> </td></tr>

          <tr><td align='center'>1</td>

          <td align='left'>Rank-Error (R)</td>

          <td align='left'><xref target='RFC6553'/> </td></tr>

          <tr><td align='center'>2</td>

          <td align='left'>Forwarding-Error (F)</td>

          <td align='left'><xref target='RFC6553'/> </td></tr>

          <tr><td align='center'>3</td>

          <td align='left'>Projected-Route (P)</td>

          <td align='left'>This document</td></tr>
    </tbody>
        </table>
   </section><!-- New Subregistry For The RPL Option Flags -->

   <section anchor='RPLCtrlMsgReg'><name>New RPL Control Codes</name>

    <t>This document extends the IANA Subregistry created by RFC 6550 for RPL
    Control Codes as indicated in <xref target="ianaRPLCtrlMsgtbl"/>:</t>


        <table anchor="ianaRPLCtrlMsgtbl"><name>New RPL Control Codes</name>
   <thead>
          <tr><th align='center'>Code</th>

          <th align='left'>Description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0x09</td>

          <td align='left'>Projected DAO Request (PDR)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>0x0A</td>

          <td align='left'>PDR-ACK</td>

          <td align='left'>This document</td></tr>
   </tbody>
        </table>


   </section> <!-- "New RPL Control Codes" -->

   <section anchor='RPLCtrlMsgOptionsReg'><name>New RPL Control Message Options</name>

    <t>This document extends the IANA Subregistry created by RFC 6550 for
    RPL Control Message Options as indicated in <xref target="ianaRPLCtrlMsgopttbl"/>:</t>



        <table anchor="ianaRPLCtrlMsgopttbl"><name>RPL Control Message Options</name>
   <thead>
          <tr><th align='center'>Value</th>

          <th align='left'>Meaning</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0x0B</td>

          <td align='left'>Stateful VIO (SM-VIO)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>0x0C</td>

          <td align='left'>Source-Routed VIO (NSM-VIO)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>0x0D</td>

          <td align='left'>Sibling Information option</td>

          <td align='left'>This document</td></tr>
   </tbody>
        </table>

   </section> <!-- "RPL Control Message Options" -->

<!--


   <section anchor='IANAMop'>
   <name>Updating Registry for the RPL Mode of Operation</name>
    <t>This document is updating the registry created by RFC 6550 for the RPL
        3-bit Mode of Operation (MOP) as follows:
        </t>

        <table anchor="ianaMOPtbl"><name>DIO Mode of operation</name>
   <thead>

          <tr><th align='center'>MOP value</th>

          <th align='left'>Description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>5</td>

          <td align='left'>Non-Storing Mode of operation with P-Routes</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>6</td>

          <td align='left'>Storing Mode of operation with P-Routes</td>

          <td align='left'>This document</td></tr>
    </tbody>
        </table>

   </section> < Updating Registry for the RPL Mode of Operation >
        -->



   <section anchor='RPLPDRflagReg'>
   <name>SubRegistry for the Projected DAO Request Flags</name>

   <t>
   IANA is required to create a registry for the 8-bit Projected DAO Request
   (PDR) Flags field. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>. The initial allocation is as indicated in <xref target='RPLPDRflagRegtbl'/>:
 </t>

        <table anchor="RPLPDRflagRegtbl"><name>Initial PDR Flags</name>
   <thead>

          <tr><th align='center'>Bit number</th>

          <th align='left'>Capability description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0</td>

          <td align='left'>PDR-ACK request (K)</td>

          <td align='left'>This document</td></tr>

          <tr><td align='center'>1</td>

          <td align='left'>Requested path should be redundant (R)</td>

          <td align='left'>This document</td></tr>
    </tbody>
        </table>

   </section> <!-- SubRegistry for the Projected DAO Request Flags -->


   <section anchor='RPLPDRackflagReg'>
   <name>SubRegistry for the PDR-ACK Flags</name>

   <t>
   IANA is required to create an subregistry for the 8-bit PDR-ACK Flags field.
   Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t>Registration procedure is "Standards Action" <xref target='RFC8126'/>.
    No bit is currently defined for the PDR-ACK Flags.
   </t>

   </section> <!-- SubRegistry for the PDR-ACK Flags -->



<section anchor='iana-stats-nonrej'>
<name>Subregistry for the PDR-ACK Acceptance Status Values </name>
 <t>
	IANA is requested to create a Subregistry for the PDR-ACK Acceptance
    Status values.
</t>
<ul spacing='normal'>
  <li> Possible values are 6-bit unsigned integers (0..63).</li>
  <li> Registration procedure is "Standards Action" <xref target='RFC8126'/>.</li>
  <li> Initial allocation is as indicated in <xref target='iana-ack-status'/>:</li>
</ul>




   <table anchor='iana-ack-status'><name>Acceptance values of the PDR-ACK Status</name>
   <thead>
      <tr><td>Value</td><td>Meaning</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>0</td><td>Unqualified Acceptance</td><td>This document</td></tr>
   </tbody>

   </table>


</section><!-- Subregistry for the PDR-ACK Acceptance Status Values -->


<section anchor='iana-stats-rej'>
<name>Subregistry for the PDR-ACK Rejection Status Values</name>
 <t>
	IANA is requested to create a Subregistry for the PDR-ACK Rejection
    Status values.
</t>
<ul spacing='normal'>
  <li> Possible values are 6-bit unsigned integers (0..63).</li>
  <li> Registration procedure is "Standards Action" <xref target='RFC8126'/>.</li>
  <li> Initial allocation is as indicated in <xref target='iana-nack-status'/>:</li>
</ul>


   <table anchor='iana-nack-status'><name>Rejection values of the PDR-ACK Status</name>
   <thead>
      <tr><td>Value</td><td>Meaning</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>0</td><td>Unqualified Rejection</td><td>This document</td></tr>
      <tr><td>1</td><td>Transient Failure</td><td>This document</td></tr>
   </tbody>

   </table>

</section><!-- Subregistry for the PDR-ACK Rejection Status Values -->



   <section anchor='RPLVIOflagReg'>
   <name>SubRegistry for the Via Information Options Flags</name>

   <t>
   IANA is requested to create a Subregistry for the 5-bit Via Information Options
   (Via Information Option) Flags field. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>.
   No bit is currently defined for the Via Information Options (Via Information Option) Flags.
   </t>

   </section> <!-- SubRegistry for the Via Information Options Flags -->


   <section anchor='RPLSIOflagReg'>
   <name>SubRegistry for the Sibling Information Option Flags</name>

   <t>
   IANA is required to create a registry for the 5-bit Sibling Information
   Option (SIO) Flags field. Each bit is Tracked with the following qualities:
   </t>
   <ul>
     <li>Bit number (counting from bit 0 as the most significant bit)</li>
     <li>Capability description</li>
     <li>Reference</li>
   </ul>

 <t> Registration procedure is "Standards Action" <xref target='RFC8126'/>. The initial allocation is as indicated in <xref target='RPLSIORegtbl'/>:
 </t>

        <table anchor="RPLSIORegtbl"><name>Initial SIO Flags</name>
   <thead>

          <tr><th align='center'>Bit number</th>

          <th align='left'>Capability description</th>

          <th align='left'>Reference</th></tr>

   </thead><tbody>

          <tr><td align='center'>0</td>

          <td align='left'>Connectivity is bidirectional (B)</td>

          <td align='left'>This document</td></tr>

    </tbody>
        </table>

   </section> <!-- SubRegistry for the Sibling Information Option Flags -->




<section anchor="iana-P-DAO"><name>New Destination Advertisement Object Flag</name>


<t>
   This document modifies the "Destination Advertisement Object (DAO) Flags"
   registry initially
   created in Section 20.11 of <xref target='RFC6550'/> .
</t><t>
  <xref target='extP-DAO'/> also defines one new entry in the Registry as follows:
    </t>

   <table  anchor="iana-P-DAOtbl">
      <name>New Destination Advertisement Object (DAO) Flag</name>
   <thead>
      <tr><td>Bit Number</td><td>Capability Description</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>2 (suggested)</td><td>Projected DAO (P)</td><td>THIS RFC</td></tr>
   </tbody>
   </table>

   </section>



   <section anchor='ICMPv6ErrPRoute'>
        <name>New ICMPv6 Error Code</name>
        <t>In some cases RPL will return an ICMPv6 error message when a
        message cannot be forwarded along a P-Route.</t>

        <t>IANA has defined an ICMPv6 "Code" Fields Registry for ICMPv6
        Message Types. ICMPv6 Message Type 1 describes "Destination Unreachable"
        codes. This specification requires that a new code is allocated from the
        ICMPv6 Code Fields Registry for ICMPv6 Message Type 1, for "Error in
        P-Route", with a suggested code value of 8, to be confirmed by
        IANA.</t>
   </section> <!--"ICMPv6: Error in a P-Route" -->



<section anchor='iana-stats-rpl-rej'><name>New RPL Rejection Status values </name>
 <t>
	This specification updates the Subregistry for the "RPL Rejection Status"
    values under the RPL registry, as follows:
</t>

   <table anchor='iana-nack-Status'><name>Rejection values of the RPL Status </name>
   <thead>
      <tr><td>Value</td><td>Meaning</td><td>Reference</td></tr>
   </thead><tbody>
      <tr><td>2 (suggested)</td><td>Out of Resources</td><td>THIS RFC</td></tr>
      <tr><td>3 (suggested)</td><td>Error in VIO</td><td>THIS RFC</td></tr>
      <tr><td>4..63</td><td>Unassigned</td><td></td></tr>
   </tbody>

   </table>

</section> <!-- Subregistry for RPL Rejection Status values -->


</section> <!-- "IANA Considerations"-->


<section><name>Acknowledgments</name>
<t>The authors wish to acknowledge JP Vasseur, Remy Liubing, James Pylakutty,
   and Patrick Wetterwald for their contributions to the ideas developed here.
   Many thanks to Dominique Barthel and SVR Anand for their global contribution
   to 6TiSCH, RAW and this document, as well as text suggestions that were
   incorporated, and to Michael Richardson for his useful recommendations based
   on his global view of the system.
   Also special thanks Toerless Eckert for his deep review, with many excellent
   suggestions that improved the readability and well as the content of the
   specification.
  </t>
</section>

    </middle>
    <back>

   <displayreference   target="RFC1122"    to="INT-ARCHI"/>
   <displayreference   target="RFC4944"        to="6LoWPAN"/>
   <displayreference   target="RFC6550"        to="RPL"/>
   <displayreference   target="I-D.ietf-raw-architecture"   to="RAW-ARCHI"/>
   <displayreference   target="I-D.ietf-raw-use-cases"   to="USE-CASES"/>
   <displayreference   target="RFC9030"    to="6TiSCH-ARCHI"/>
   <displayreference   target="RFC9035" to="TURN-ON_RFC8138"/>

    <references><name>Normative References</name>

	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4443.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4655.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5551.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6282.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6550.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6553.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6554.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml'/>

    </references><references><name>Informative References</name>

	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7102.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6997.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7416.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9030.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-raw-architecture.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-raw-use-cases.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9035.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8655.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8025.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8138.xml'/>

	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8505.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8930.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8931.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8994.xml'/>
	  <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9008.xml'/>
      <xi:include href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.9010.xml'/>

     <xi:include href="http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.irtf-panrg-path-properties.xml"/>
      <reference anchor='PCE' target='https://dataTracker.ietf.org/doc/charter-ietf-pce/'>
         <front>
            <title>Path Computation Element</title>
            <author>
               <organization>IETF</organization>
            </author>
            <date/>
         </front>
      </reference>

    </references>

	<section><name>Applications</name>

       <section anchor='loose'><name>Loose Source Routing</name>


	  <t>A RPL implementation operating in a very constrained LLN typically uses
      the Non-Storing Mode of Operation as represented in <xref target='nost'/>.
      In that mode, a RPL node indicates a
      parent-child relationship to the Root, using a Destination Advertisement
      Object (DAO) that is unicast from the node directly to the Root,
      and the Root typically builds a source routed path to a destination down
      the DODAG by recursively concatenating this information.
      </t>

          <figure anchor='nost'><name>RPL Non-Storing Mode of operation </name>
            <artwork>
           ------+---------
                 |          Internet
                 |
              +-----+
              |     | Border Router
              |     |  (RPL Root)
              +-----+                      ^     |        |
                 |                         | DAO | ACK    |
           o    o   o    o                 |     |        | Strict
       o o   o  o   o  o  o o   o          |     |        | Source
      o  o o  o o    o   o   o  o  o       |     |        | Route
      o   o    o  o     o  o    o  o  o    |     |        |
     o  o   o  o   o         o   o o       |     v        v
     o          o             o     o
                       LLN
                       </artwork>
          </figure>
    <t>
      Based on the parent-children relationships expressed in the Non-Storing
      DAO messages,the Root possesses topological information about the whole
      network, though this information is limited to the structure of the DODAG
      for which it is the destination.
      A packet that is generated within the domain will always reach the Root,
      which can then apply a source routing information to reach the destination
      if the destination is also in the DODAG.
      Similarly, a packet coming from the outside of the domain for a destination
      that is expected to be in a RPL domain reaches the Root.
    </t>
    <t>
     It results that the Root, or then some associated centralized computation
     engine such as a PCE, can determine the amount of packets that reach a
     destination in the
     RPL domain, and thus the amount of energy and bandwidth that is wasted for
     transmission, between itself and the destination, as well as the risk of
     fragmentation, any potential delays because of a paths longer than
     necessary (shorter paths exist that would not traverse the Root).
    </t>
     <t>
     As a network gets deep, the size of the source routing header that the
      Root must add to all the downward packets becomes an issue for nodes that
      are many hops away. In some use cases, a RPL network forms long lines and
      a limited amount of well-Targeted routing state would allow to make the
      source routing operation loose as opposed to strict, and save packet size.
      Limiting the packet size is directly beneficial to the energy budget, but,
      mostly, it reduces the chances of frame loss and/or packet fragmentation,
      which is highly detrimental to the LLN operation. Because the capability
      to store a routing state in every node is limited, the decision of which
      route is installed where can only be optimized with a global knowledge of
      the system, a knowledge that the Root or an associated PCE may possess by
      means that are outside of the scope of this specification.
      </t>

      <t>
      This specification enables to store a Storing Mode state in
      intermediate routers, which enables to limit the excursion of the source
      route headers in deep networks.
      Once a P-DAO exchange has taken place for a given Target, if the Root
      operates in non Storing Mode, then it may elide the sequence of routers
      that is installed in the network from its source route headers to
      destination that are reachable via that Target, and the source route
      headers effectively become loose.
      </t>

      </section> <!-- Loose Source Routing -->
    <section><name>Transversal Routes</name>

      <t>
      RPL is optimized for Point-to-Multipoint (P2MP) and Multipoint-to-Point
      (MP2P), whereby routes are always installed along the RPL DODAG
      respectively from and towards the DODAG Root. Transversal
      Peer to Peer (P2P) routes in a RPL network will generally suffer from some
      elongated (stretched) path versus the best possible path, since routing
      between 2 nodes always happens via a common parent, as illustrated in
      <xref target='stretch'/>:
        </t><ul spacing='normal'>
        <li>In Storing Mode, unless the destination is a child of the source,
     the packets will follow the default route up the DODAG as well.
     If the destination is in the same DODAG, they will eventually reach a
     common parent that has a route to the destination; at worse, the common
     parent may also be the Root. From that common parent, the packet will
     follow a path down the DODAG that is optimized for the Objective Function
     that was used to build the DODAG.</li>
        <li> in Non-Storing Mode, all packets
     routed within the DODAG flow all the way up to the Root of the DODAG. If
     the destination is in the same DODAG, the Root must encapsulate the packet
     to place an RH that has the strict source route information down
     the DODAG to the destination. This will be the case even if the destination
     is relatively close to the source and the Root is relatively far off.
        </li>
        </ul><t>
     </t>


       <figure anchor='stretch'><name>Routing Stretch between S and D via common parent X</name>
            <artwork>
                   ------+---------
                    |          Internet
                    |
                 +-----+
                 |     | Border Router
                 |     |  (RPL Root)
                 +-----+
                    X
              ^    v   o    o
          ^ o   o  v   o  o  o o   o
         ^  o o  o v    o   o   o  o  o
         ^   o    o  v     o  o    o  o  o
        S  o   o  o   D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>



     <t>
     It results that it is often beneficial to enable transversal P2P routes,
     either if the RPL route presents a stretch from shortest path, or if the
     new route is engineered with a different objective, and that it is
     even more critical in Non-Storing Mode than it is in Storing Mode, because
     the routing stretch is wider.
     For that reason, earlier work at the IETF introduced the
     <xref target='RFC6997'>"Reactive Discovery of Point-to-Point Routes in
     Low Power and Lossy Networks"</xref>, which specifies a distributed method for
     establishing optimized P2P routes. This draft proposes an alternate based
     on a centralized route computation.
     </t>

        <figure anchor='opti2'><name>Projected Transversal Route</name>
            <artwork>
              ------+---------
                    |          Internet
                    |
                 +-----+
                 |     | Border Router
                 |     |  (RPL Root)
                 +-----+
                    |
              o    o   o    o
          o o   o  o   o  o  o o   o
         o  o o  o o    o   o   o  o  o
         o   o    o  o     o  o    o  o  o
        S>>A>>>B>>C>>>D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>
            <t>
      This specification enables to store source-routed or Storing Mode state in
      intermediate routers, which enables to limit the stretch of a P2P route
      and maintain the characteristics within a given SLA. An example of service
      using this mechanism oculd be a control loop that would be installed in a
      network that uses classical RPL for asynchronous data collection. In that
      case, the P2P path may be installed in a different RPL Instance, with a
      different objective function.
      </t>
      </section>
      </section>

    </back>




</rfc>
