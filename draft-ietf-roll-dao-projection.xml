<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc    SYSTEM "rfc2629.dtd" [
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<rfc category="std" ipr="trust200902" docName="draft-ietf-roll-dao-projection-latest">

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

<?rfc sortrefs="yes"?>
<?rfc iprnotified="no" ?>
<?rfc authorship="yes"?>
<?rfc tocappendix="yes"?>
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="no" ?>
<!-- Q:
more than one RPO? If so mixing RPO types?
loop avoidance using SR only, or accept others?
inter DODAG routing?
 -->
    <front>
        <title>Root initiated routing state in RPL</title>
        <author initials="P" surname="Thubert" fullname="Pascal Thubert" role="editor">
          <organization abbrev="Cisco">
             Cisco Systems
          </organization>
          <address>
            <postal>
             <street>Village d'Entreprises Green Side</street>
             <street>400, Avenue de Roumanille</street>
	     <street>Batiment T3</street>
             <city>Biot - Sophia Antipolis</city>
             <code>06410</code>
             <country>FRANCE</country>
            </postal>
            <phone>+33 4 97 23 26 34</phone>
            <email>pthubert@cisco.com</email>
	  </address>
        </author>

<author fullname="Rahul Arvind Jadhav" initials="R.A." surname="Jadhav">
  <organization>Huawei Tech</organization>
  <address>
    <postal>
      <street>Kundalahalli Village, Whitefield,</street>
      <city>Bangalore</city>
      <region>Karnataka</region>
      <code>560037</code>
      <country>India</country>
    </postal>
    <phone>+91-080-49160700</phone>
    <email>rahul.ietf@gmail.com</email>
  </address>
</author>

	<author fullname="James Pylakutty" initials="J.P." surname="Pylakutty">
          <organization abbrev="Cisco">
             Cisco Systems
          </organization>
          <address>
            <postal>
             <street>Cessna Business Park</street>
             <street>Kadubeesanahalli</street>
	     <street>Marathalli ORR</street>
             <city>Bangalore</city>
             <region>Karnataka</region>
             <code>560087</code>
             <country>INDIA</country>
            </postal>
            <phone>+91 80 4426 4140</phone>
            <email>mundenma@cisco.com</email>
	  </address>
	</author>
        <date/>

	<area>Routing</area>

	<workgroup>ROLL</workgroup>

        <abstract>
	  <t>
		This document proposes a  protocol extension to RPL that enables to
        install a limited amount of centrally-computed routes in a RPL graph,
        enabling loose source routing down a non-storing mode DODAG, or
        transversal routes inside the DODAG.
        As opposed to the classical route injection in RPL that are injected
        by the end devices, this draft enables the root of the DODAG to
        projects the routes that are needed on the nodes where they should be
        installed.
	  </t>
	</abstract>
    </front>

    <middle>

	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<section anchor='introduction' title="Introduction">

	   <t> The <xref target="RFC6550">
	 "Routing Protocol for Low Power and Lossy Networks"</xref> (LLN)(RPL)
     is a generic Distance Vector protocol that is well suited for application
     in a variety of low energy Internet of Things (IoT) networks.

     RPL forms Destination Oriented Directed Acyclic Graphs (DODAGs) in which
     the root often acts as the Border Router to connect the RPL domain to the
     Internet. The root is responsible to select the RPL Instance that is used
     to forward a packet coming from the Internet into the RPL domain and set
     the related RPL information in the packets.
	  </t>



     <t>
      The  <xref target="I-D.ietf-6tisch-architecture">
      6TiSCH architecture </xref> leverages RPL for its routing operation and
      considers the <xref target="I-D.ietf-detnet-architecture">
      Deterministic Networking Architecture</xref> as one possible model
      whereby the device resources and capabilities are exposed to an external
      controller which installs routing states into the network based on some
      objective functions that reside in that external entity.
	  </t>
     <t>
     Based on heuristics of usage, path length, and knowledge of device capacity
     and available resources such as battery levels and reservable buffers, a
     Path Computation Element (<xref target="PCE"/>) with a global visibility
     on the system could install additional P2P routes that are more optimized
     for the current needs as expressed by the objective function.
	  </t>
     <t>
     This draft enables a RPL root to install and maintain projected routes
     (P-routes) within its DODAG, along a selected set of nodes that may or may
     not include self, for a chosen duration. This potentially enables routes
     that are more optimized than those obtained with the distributed operation
     of RPL, either in terms of the size of a source-route header or in terms of
     path length, which impacts both the latency and the packet delivery ratio.
     P-routes may be installed in either Storing and Non-Storing Modes Instances
     of the classical RPL operation, resulting in potentially hybrid situations
     where the mode of some P-routes is different from that of the other routes
     in the RPL Instance.
	  </t>
     <t>
     Projected routes must be used with the parsimony to limit the amount of
     state that is installed in each device to fit within its resources, and to
     limit the amount of rerouted traffic to fit within the capabilities of the
     transmission links.
     The algorithm used to compute the paths and the protocol used to learn the
     topology of the network and the resources that are available in devices and
     in the network are out of scope for this document.
     Possibly with the assistance of a Path Computation Element
     (<xref target="PCE"/>) that could have a better visibility on the
     larger system, the root computes which segment could be optimized and uses
     this draft to install the corresponding projected routes.
    </t>
     <!--
    <t>
     It is envisaged that the computation could use the ratio
     between the optimal path (existing path not traversing the root, and the
     current path), the application service level agreement (SLA) for specific
     flows that could benefit from shorter paths, the energy wasted in the
     network, local congestion on various links that would benefit from having
     flows routed along alternate paths.
    </t>
    <t>
     In particular, the draft expects that the root has enough information about
     the capability
     for each node to store a number of routes, which can be discovered for
     instance using a Network Management System (NMS) and/or the RPL routing
     extensions specified in
      <xref target="RFC6551">"Routing for Path Calculation in LLNs"</xref>.
    </t>
     -->
    </section>

	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->
	<!-- **************************************************************** -->

<section title="Terminology">
<section anchor='bcp' title="BCP 14">
<t>

    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
    "OPTIONAL" in this document are to be interpreted as described in BCP 14
    <xref target="RFC2119"/><xref target="RFC8174"/> when, and only when, they
    appear in all capitals, as shown here.

</t>
</section>	<!-- end section "BCP 14" -->


  <section anchor='lo' title="References">
    <t>
	In this document, readers will encounter terms and concepts
	that are discussed in the following documents:
	<list style="symbols">
<!--  CEP: There aren't any terms from RFC 3972.  Concepts, O.K.   -->
	<t>
    <xref target="RFC6550">"Routing Protocol for Low Power and Lossy Networks"
		</xref>, and </t>
	<t>
    <xref target="RFC7102">"Terminology in Low power And Lossy Networks"
		</xref>. </t>

	</list>
    </t>
  </section>	<!-- end section "References" -->

<section anchor='gloss' title="Subset of a 6LoWPAN Glossary">
    <t> This document often uses the following acronyms:
       <list hangIndent="6" style="hanging">
       <t hangText="6BBR:"> 6LoWPAN Backbone Router </t>
       <t hangText="6LBR:"> 6LoWPAN Border Router </t>
       <t hangText="6LN:"> 6LoWPAN Node  </t>
       <t hangText="6LR:"> 6LoWPAN Router </t>
       <t hangText="6CIO:"> Capability Indication Option </t>
       <t hangText="EARO:"> (Extended) Address Registration Option -- (E)ARO</t>
       <t hangText="EDAR:"> (Extended) Duplicate Address Request  -- (E)DAR</t>
       <t hangText="EDAC:"> (Extended) Duplicate Address Confirmation  --
				(E)DAC</t>
       <t hangText="DAD:"> Duplicate Address Detection </t>
       <t hangText="DODAG:"> Destination-Oriented Directed Acyclic Graph </t>
       <t hangText="LLN:"> Low-Power and Lossy Network </t>
       <t hangText="NA:">  Neighbor Advertisement </t>
       <t hangText="NCE:">  Neighbor Cache Entry  </t>
       <t hangText="ND:">  Neighbor Discovery  </t>
       <t hangText="NDP:">  Neighbor Discovery Protocol </t>
       <t hangText="NS:">  Neighbor Solicitation  </t>
       <t hangText="RPL:"> IPv6 Routing Protocol for LLNs
					(pronounced ripple) <xref target="RFC6550"/> </t>
       <t hangText="RA:">  Router Advertisement  </t>
       <t hangText="RS:">  Router Solicitation  </t>
       </list>
    </t>
</section>	<!-- end section "Subset of a 6LoWPAN Glossary" -->

<section anchor='new' title="New Terms">
    <t>
    <!-- Removed reference from routing and 6tisch here to keep it simple
	 This specification introduces the following terminology:-->
    <list hangIndent="6" style="hanging">
    <t hangText="Projected Route:">
	A route that is installed remotely by a RPL root.

    </t>
    </list>
</t>
</section>	<!-- end section "New Terms" -->
</section>	<!-- end section "Terminology" -->


    <section anchor="ext6550" title="Extending RFC 6550">
	<t>
	Section 6.7 of RPL <xref target="RFC6550"/> specifies Control Message Options (CMO)
   to be placed in RPL messages such as the Destination Advertisement Object
   (DAO) message. The RPL Target Option
   and the Transit Information Option (TIO) are such options; the former
   indicates a node to be reached and the latter specifies
   a parent that can be used to reach that node. Options may be factorized;
   one or more contiguous TIOs apply to the one or more contiguous Target
   options that immediately precede the TIOs in the RPL message.
   </t>
   <t>
   This specification introduces 2 new Control Message Options referred to as
   Route Projection Options (RPO). One RPO is the Information option (VIO) and
   the other is the Source-Routed VIO (SRVIO). The VIO installs a route on each
   hop along a projected route (in a fashion analogous to RPL Storing Mode)
   whereas the SRVIO installs a source-routing state at the ingress node, which
   uses it to insert a routing header in a fashion similar to Non-Storing Mode.
   </t>
   <t>
    Like the TIO, the RPOs MUST be preceded by one or more RPL Target Options to
    which they apply, and they can be factorized: multiple contiguous RPOs
    indicate alternate paths to the target(s).
   </t>

    </section>     <!-- "Extending RFC 6550"> -->

    <section anchor="rplccmo" title="New RPL Control Message Options">


    <t>The format of RPOs is as follows:
    </t>
<figure anchor="viao" title="Via Information option format">
              <artwork>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Type        | Option Length | Path Sequence | Path Lifetime |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .                     Via Address 1                             .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    .                              ....                             .
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    +                                                               +
    .                                                               .
    .                     Via Address n                             .
    .                                                               .
    +                                                               +
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 </artwork>
</figure>

          <t><list hangIndent="6" style="hanging">
              <t hangText="Option Type:">0x0A for VIO, 0x0B for SRVIO
                                     (to be confirmed by IANA)</t>

              <t hangText="Option Length:">In bytes; variable, depending on the number
              of Via Addresses.</t>

              <t hangText="Path Sequence:">8-bit unsigned integer. When a RPL
              Target option is issued by the root of the DODAG
              (i.e. in a DAO message), that root sets the Path Sequence and
              increments the Path Sequence each time it issues a RPL Target
              option with updated information. The indicated sequence
              deprecates any state for a given Target that was learned from a
              previous sequence and adds to any state that was learned for
              that sequence.</t>

              <t hangText="Path Lifetime:">8-bit unsigned integer. The length
              of time in Lifetime Units (obtained from the Configuration
              option) that the prefix is valid for route determination. The
              period starts when a new Path Sequence is seen. A value of all
              one bits (0xFF) represents infinity. A value of all zero bits
              (0x00) indicates a loss of reachability. A DAO message that
              contains a Via Information option with a Path Lifetime of
              0x00 for a Target is referred as a No-Path (for that Target) in
              this document.</t>

              <t hangText="Via Address:">16 bytes. IPv6 Address of the
              next hop towards the destination(s) indicated in the target option
              that immediately precede the RPO. Via Addresses are indicated in
              the order of the data path from the ingress to the egress nodes.
              TBD: See how the /64 prefix can be elided if it is the same as
              that of (all of) the target(s). In that case, the Next-Hop Address
              could be expressed as the 8-bytes suffix only.
              </t>
            </list></t>
               <t>
    An RPO MUST contain at least one Via Address, and a Via Address MUST NOT be
    present more than once, otherwise the RPO MUST be ignored.
    </t>
    </section> <!--"New RPL Control Message Options"-->


    <section anchor="pdao" title="Projected DAO">

    <t>
    This draft adds a capability to RPL whereby the root of a DODAG projects a
    route by sending an extended DAO message called a Projected-DAO (P-DAO) to an
    arbitrary router in the DODAG, indicating one or more sequence(s) of routers
    inside the DODAG via which the target(s) indicated in the Target Information
    Option(s) (TIO) can be reached.
     </t> <t>
    A P-DAO is sent from a global address of the root to a global address of the
    recipient, and MUST be confirmed by a DAO-ACK, which is sent back to a
    global address of the root.
     </t> <t>
    A P-DAO message MUST contain at least one TIO and at least one RPO following
    it. There can be at most one such sequence of TIOs and then RPOs.
     </t> <t>
    Like a classical DAO message, a P-DAO is processed only if it is "new"
    per section 9.2.2. "Generation of DAO Messages" of the <xref target="RFC6550">
    RPL specification</xref>; this is determined using the Path Sequence
    information from the RPO as opposed to a TIO. Also, a Path Lifetime of 0 in
    an RPO indicates that a route is to be removed.
     </t> <t>
    There are two kinds of operation for the projected routes, the Storing Mode
    and the Non-Storing Mode.
    <list>
     <t>
    The Non-Storing Mode is discussed in section <xref target="nspdao"/>.
    It uses an SRVIO that carries a list of Via Addresses to be used as a
    source-routed path to the target. The recipient of the P-DAO is the
    ingress router of the source-routed path. Upon a Non-Storing Mode P-DAO, the
    ingress router installs a source-routed state to the target and replies to
    the root directly with a DAO-ACK message.
     </t>
    <t>
    The Storing Mode is discussed in section  <xref target="spdao"/>. It uses
    a VIO with one Via Address per consecutive hop, from the ingress to the
    egress of the path, including the list of all intermediate routers in the
    data path order.
    The Via Addresses indicate the routers in which the routing state to the
    target have to be installed via the next Via Address in the VIO.
    In normal operations, the P-DAO is propagated along the chain of Via Routers
    from the egress router of the path till the ingress one, which confirms the
    installation to the root with a DAO-ACK message.
    Note that the root may be the ingress and it may be the egress of the
    path, that it can also be neither but it cannot be both.
     </t>
     </list>

    </t>

    <!--t>
    Note: The target of a route that is installed by a P-DAO is not necessarily
    inside the DODAG, though how the root and the optional PCE obtain the
    additional topological information to compute other routes is out of scope
    for this document.
    </t-->

    <section anchor="nspdao"  title="Non-storing Mode Projected Route">

    <t>
    As illustrated in <xref target="nsdf"/>, a P-DAO that carries an SRVIO
    enables the root to install a source-routed path towards a target in any
    particular router; with this path information the router can add a source
    routed header reflecting the P-route to any packet for which the current
    destination either is the said target or can be reached via the target.
    </t>

          <figure anchor="nsdf" title="Projecting a Non-Storing Route">
            <artwork>
           ------+---------
                 |          Internet
                 |
              +-----+
              |     | Border Router
              |     |  (RPL Root)
              +-----+                   |  P  ^            |
                 |                      | DAO | ACK        | Loose
           o    o   o    o     router   V     |            | Source
       o o   o  o   o  o  o      o  o            | P-DAO   . Route
      o  o o  o o    o   o   o  o  o             | Source  . Path
      o   o    o  o     o  o    o  o  o          | Route   . From
     o  o   o  o   o         o   o o             | Path    . Root
        o  o  o  o             o    target       V         . To
       o       o               o    o                      | Desti-
     o          o             o     o                      | nation
                                   destination             V

                       LLN
                       </artwork>
          </figure>
    <t>
    A route indicated by an SRVIO may be loose, meaning that the node that owns
    the next listed Via Address is not necessarily a neighbor. Without proper
    loop avoidance mechanisms, the interaction of loose source routing and other
    mechanisms may effectively cause loops. In order to avoid those loops, if
    the router that installs a P-route does not have a connected route
    (a direct adjacency) to the next soure routed hop and fails to locate it as
    a neighbor or a neighbor of a neighbor, then it MUST ensure that it has
    <!-- a loopless path to it that will not interact with the projected route, for instance  -->
    another projected route to the next loose hop under the control of the same
    route computation system, otherwise the P-DAO is rejected.
    </t>
    <t>
      When forwarding a packet to a destination for which the router determines
      that routing happens via the target, the router inserts the source routing
      header in the packet to reach the target. In the case of a loose
      source-routed path, there MUST be either a neighbor that is adjacent to the
      loose next hop, on which case the packet s forwarded to that neighbor, or
      a source-routed path to the loose next hop; in the latter case,
      another encapsulation takes place and the process possibly recurses;
      otherwise the packet is dropped.
     </t>
    <t>
      In order to add a source-routing header, the router encapsulates the
      packet with an IP-in-IP header and a non-storing mode source routing
      header (SRH) <xref target="RFC6554"/>.</t>
    <t>
      In the uncompressed form the source of the packet would be self, the
      destination would be the first Via Address in the SRVIO, and the SRH would
      contain the list of the remaining Via Addresses and then the target.</t>
    <t>
      In practice, the router will normally use the <xref target="RFC8025">
      "IPv6 over Low-Power Wireless Personal Area Network (6LoWPAN) Paging
      Dispatch"</xref> to compress the RPL artifacts as indicated in the
      <xref target="RFC8138">"6LoWPAN Routing Header"
      </xref> specification. In that case, the router indicates self as
      encapsulator in an IP-in-IP 6LoRH Header, and places the list of Via
      Addresses in the order of the VIO and then the target in the SRH 6LoRH
      Header.
      </t>
      </section>



    <section anchor="spdao"  title="Storing-Mode Projected Route">


      <t> As illustrated in <xref target="sdf"/>, the Storing Mode projected iq
      used by the root to install a routing state towards a target in the routers
      along a segment between an ingress and an egress router;
      this enables the routers to forward along that segment any packet for
      which the next loose hop is the said target, for instance a loose source
      routed packet for which the next loose hop is the target, or a packet for
      which the router has a routing state to the final destination via the target.
      </t>
          <figure anchor="sdf" title="Projecting a route">
            <artwork>
           ------+---------
                 |          Internet
                 |
              +-----+
              |     | Border Router
              |     |  (RPL Root)
              +-----+                      |     ^                   |
                 |                         | DAO | ACK               |
           o    o   o    o                 |     |                   |
       o o   o  o   o  o  o o   o          |  ^       | Projected    .
      o  o o  o o    o   o   o  o  o       |  | DAO   | Route        .
      o   o    o  o     o  o    o  o  o    | ^        |              .
     o  o   o  o   o         o   o o       v | DAO    v              .
     o          o   LLN   o   o     o                                |
         o o   o        o     o              Loose Source Route Path |
      o       o      o    o                 From Root To Destination v

      </artwork>
          </figure>


    <t>
     In order to install the relevant routing state along the segment between an
     ingress and an egress routers,
     the root sends a unicast P-DAO message to the egress router of the routing
     segment that must be installed. The P-DAO message contains the ordered list
     of hops along the segment as a direct sequence of Via Information options
     that are preceded by one or more RPL Target options to which they relate.
     Each Via Information option contains a Path Lifetime for which the state is
     to be maintained.
     </t><t>
     The root sends the P-DAO directly to the egress node of the segment.
     In that P-DAO, the destination IP address matches the Via Address in the
     last VIO. This is how the egress recognizes its role. In a similar fashion,
     the ingress node recognizes its role as it matches Via Address in the first
     VIO.
     </t><t>

     The egress node of the segment is the only node in the path that does not
     install a route in response to the P-DAO; it is expected to be already able
     to route to the target(s) on its own. It may either be the target, or may
     have some existing information to reach the target(s), such as a connected
     route or an already installed projected route.
    <!-- If it cannot reach the target, then the egress node may lookup the address on the relevant interfaces. -->
     If one of the targets cannot be located, the node MUST answer to the root
     with a negative DAO-ACK listing the target(s) that could not be located
     (suggested status 10 to be confirmed by IANA).
    </t><t>
     If the egress node can reach all the targets, then it forwards the P-DAO
     with unchanged content to its loose predecessor in the segment as indicated
     in the list of Via Information options, and recursively the message is propagated
     unchanged along the sequence of routers indicated in the P-DAO, but in the
     reverse order, from egress to ingress.
     </t><t>

     The address of the predecessor to be used as destination of the propagated
     DAO message is found in the Via Information option the precedes the one
     that contain the address of the propagating node, which is used as source
     of the packet.

    </t><t>
     Upon receiving a propagated DAO, an intermediate router as well as the
     ingress router install a route towards the DAO target(s) via its
     successor in the P-DAO; the router locates the VIO that contains its
     address, and uses as next hop the address found in the Via Address field
     in the following VIO. The router MAY install additional routes towards the
     addresses that are located in VIOs that are after the next one, if any, but
     in case of a conflict or a lack of resource, a route to a target installed
     by the root has precedence.

    </t><t>
     The process recurses till the P-DAO is propagated to ingress router of
     the segment, which answers with a DAO-ACK to the root.
     </t>
     <t>Also, the path indicated in a P-DAO may be loose, in which case the
     reachability to the next hop has to be asserted. Each router along the
     path indicated in a P-DAO is expected to be able to reach its successor,
     either with a connected route (direct neighbor), or by routing, for instance
     following a route installed previously by a DAO or a P-DAO message.
     If that route is not connected then a recursive lookup may take place at
     packet forwarding time to find the next hop to reach the target(s).
     If it does not and cannot reach the next router in the P-DAO,
     the router MUST answer to the root with a negative DAO-ACK
     indicating the successor that is unreachable
     (suggested status 11 to be confirmed by IANA).
    </t>
    <t>
     A Path Lifetime of 0 in a Via Information option is used to clean up the
     state. The P-DAO is forwarded as described above, but the DAO
     is interpreted as a No-Path DAO and results in cleaning up existing state
     as opposed to refreshing an existing one or installing a new one.
    </t>
      </section>  <!-- "Storing-Mode Projected DAO" -->
    </section>  <!-- "Projected DAO" -->

    <section title="Loop Handling">
        <t>
            Section 11.2 of RPL explains loop avoidance/detection and recovery.
            The loop recovery mechanism in RPL is applicable only to storing
            mode of operation. This draft introduces hybrid mode such that the
            DODAG is formed in non-storing mode of operation but there could be
            segments projected using P-DAOs which operate in storing mode.
            P-DAOs injecting state into existing DODAG creates a possibility
            of loops occurring for following reasons:
        </t>
        <t>
            <list style="symbols">
            <t>
                Changes in route adjacencies (for e.g.  because of parent
                switching) after the routes are projected from the root.
            </t>
            <t>
                Route invalidation is probabilistic because of control packet
                loss and thus stale states might be retained on the nodes for
                longer duration.
            </t>
            </list>
        </t>
        <t>
            These reasons might result in a differing view between how root sees the
            network and how locally it is manifested, thus possibly resulting in loops.
            <figure anchor="loopeg" title="Loop Handling: Example Scenario">
            <artwork>
                +=======+
                | Root  |
                +=======+
                   /\
                  /  \
                 /    \
             +---+     \
             | A |      \
             +---+       \
              /\         +---+
             /  \        | D |
            /    \       +---+
         +---+   +---+
         | B |   | C |--\
         +---+   +---+   \
                          \
                         +---+
                         | E |
                         +---+
            </artwork>
            </figure>
        </t>
        <t>
            Consider following scenario:
            <list style="format %d:" counter="loop_cnt">
            <t>
                Assume that the network is established in non-storing mode with
                P-DAO as per the adjacencies mentioned in the figure.
            </t>
            <t>
                Assume that (B) has significant traffic for (E) and Root
                decides to project a P-DAO along the segment (A,C) for reaching
                target (E).
            </t>
            <t>
                Henceforth, (B)'s traffic for (E) takes the optimized path
                (B->A->C->E)
            </t>
            <t>
                Assume that the path between (C) and (E) is impaired. (E)
                switches the preferred parent to (D). Thus the network nows
                looks as follows:
            </t>
            </list>
        </t>
        <t>
                <figure anchor="loopeg2" title="Loop Handling: Changed Adjacencies">
                <artwork>
                +=======+
                | Root  |
                +=======+
                   /\
                  /  \
                 /    \
             +---+     \
             | A |      \
             +---+       \
              /\         +---+
             /  \        | D |
            /    \       +---+
         +---+   +---+     |
         | B |   | C |     |
         +---+   +---+     |
                           |
                         +---+
                         | E |
                         +---+
                </artwork>
                </figure>
        </t>
        <t>
            <list style="format %d:" counter="loop_cnt">
            <t>
                Any subsequent traffic from (B) to (E) will fail at (C). Note
                that link between (C) and (E) is impaired thus the traffic will
                fail.
            </t>
            <t>
                At this point (C) can clear the routing entry for target (E)
                but the corresponding routing entry for target (E) in (A) is
                not cleared.
            </t>
            <t>
                Thus the packet will get into loop at this stage i.e. the
                packet would be sent back to (A).
            </t>
            </list>
        </t>
        <section  title="Loop Detection">
            <t>
                RPL uses loop detection to ensure that packets make forward
                progress within the DODAG Version and trigger repairs when
                necessary.  Sections 11.2 of RFC6550 states the loop avoidance
                and detection procedure. The RPI header carried in data path
                can be used to detect whether there is any inconsistency in the
                path.  The same loop detection logic can be used even in the
                context of this document.  Thus there is a way to identify
                whether a loop has occurred.
            </t>
        </section>
        <section  title="Loop avoidance: recommendations">
            <t>
                Following recommendations can reduce the possibility of loop
                formation:
                <list style="numbers">
                    <t>
                        It is important that the root invalidates the route
                        segment established before using P-DAO in case it
                        notices that the adjacencies have changed.  For
                        example, in the above figure [CROSS-REF] when (E)
                        switches the parent from (C) to (D), the root node can
                        invalidate the routing entries along the previously
                        projected segment.
                    </t>
                    <t>
                        TBD: A node should be able to send multiple parent
                        address in preferred order in the Transit Information
                        container. This would allow the root node to make an
                        informed decision whether the previous path is still
                        available but not preferred or whether the connectivity
                        to previous parent is impaired.
                    </t>
                </list>
            </t>
        </section>
    </section>

	<section  title="Applications">
      <section title="Loose Source Routing in Non-storing Mode">

	  <t>A RPL implementation operating in a very constrained LLN typically uses
      the Non-Storing Mode of Operation as represented in <xref target="nost"/>.
      In that mode, a RPL node indicates a
      parent-child relationship to the root, using a Destination Advertisement
      Object (DAO) that is unicast from the node directly to the root,
      and the root typically builds a source routed path to a destination down
      the DODAG by recursively concatenating this information.
      </t>

          <figure  anchor="nost" title="RPL non-storing mode of operation ">
            <artwork>
           ------+---------
                 |          Internet
                 |
              +-----+
              |     | Border Router
              |     |  (RPL Root)
              +-----+                      ^     |        |
                 |                         | DAO | ACK    |
           o    o   o    o                 |     |        | Strict
       o o   o  o   o  o  o o   o          |     |        | Source
      o  o o  o o    o   o   o  o  o       |     |        | Route
      o   o    o  o     o  o    o  o  o    |     |        |
     o  o   o  o   o         o   o o       |     v        v
     o          o             o     o
                       LLN
                       </artwork>
          </figure>
    <t>
      Based on the parent-children relationships expressed in the non-storing
      DAO messages,the root possesses topological information about the whole
      network, though this information is limited to the structure of the DODAG
      for which it is the destination.
      A packet that is generated within the domain will always reach the root,
      which can then apply a source routing information to reach the destination
      if the destination is also in the DODAG.
      Similarly, a packet coming from the outside of the domain for a destination
      that is expected to be in a RPL domain reaches the root.
    </t>
    <t>
     It results that the root, or then some associated centralized computation
     engine such as a PCE, can determine the amount of packets that reach a
     destination in the
     RPL domain, and thus the amount of energy and bandwidth that is wasted for
     transmission, between itself and the destination, as well as the risk of
     fragmentation, any potential delays because of a paths longer than
     necessary (shorter paths exist that would not traverse the root).
    </t>
     <t>
     As a network gets deep, the size of the source routing header that the
      root must add to all the downward packets becomes an issue for nodes that
      are many hops away. In some use cases, a RPL network forms long lines and
      a limited amount of well-targeted routing state would allow to make the
      source routing operation loose as opposed to strict, and save packet size.
      Limiting the packet size is directly beneficial to the energy budget, but,
      mostly, it reduces the chances of frame loss and/or packet fragmentation,
      which is highly detrimental to the LLN operation. Because the capability
      to store a routing state in every node is limited, the decision of which
      route is installed where can only be optimized with a global knowledge of
      the system, a knowledge that the root or an associated PCE may possess by
      means that are outside of the scope of this specification.
      </t>

      <t>
      This specification enables to store source-routed or storing mode state in
      intermediate routers, which enables to limit the excursion of the source
      route headers in deep networks.
      Once a P-DAO exchange has taken place for a given target, if the root
      operates in non storing mode, then it may elide the sequence of routers
      that is installed in the network from its source route headers to
      destination that are reachable via that target, and the source route
      headers effectively become loose.
      </t>

      </section>
    <section title="Transversal Routes in storing and non-storing modes">

      <t>
      RPL is optimized for Point-to-Multipoint
      (P2MP), root to leaves and Multipoint-to-Point (MP2P) leaves to root operations,
      whereby routes are always installed along the RPL DODAG. Transversal
      Peer to Peer (P2P) routes in a RPL network will generally suffer from some
      stretch since routing between 2 peers always happens via a common parent,
      as illustrated in <xref target="stretch"/>:
        <list style="symbols">
        <t> in non-storing mode, all packets
     routed within the DODAG flow all the way up to the root of the DODAG. If
     the destination is in the same DODAG, the root must encapsulate the packet
     to place a Routing Header that has the strict source route information down
     the DODAG to the destination. This will be the case even if the destination
     is relatively close to the source and the root is relatively far off.
        </t>
        <t>In storing mode, unless the destination is a child of the source,
     the packets will follow the default route up the DODAG as well.
     If the destination is in the same DODAG, they will eventually reach a
     common parent that has a route to the destination; at worse, the common
     parent may also be the root. From that common parent, the packet will
     follow a path down the DODAG that is optimized for the Objective Function
     that was used to build the DODAG.</t>
        </list>
     </t>


       <figure  anchor="stretch"
        title="Routing Stretch between S and D via common parent X">
            <artwork>
                   ------+---------
                    |          Internet
                    |
                 +-----+
                 |     | Border Router
                 |     |  (RPL Root)
                 +-----+
                    X
              ^    v   o    o
          ^ o   o  v   o  o  o o   o
         ^  o o  o v    o   o   o  o  o
         ^   o    o  v     o  o    o  o  o
        S  o   o  o   D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>


          <!--
      In NSM, all peer-to-peer routes travel all the way to the root, which adds
      a source routing header and forwards the packet down to the destination,
      resulting in the longest stretch and overload of the radio bandwidth near
      the root. A controller, for instance collocated with the RPL root, with
      enough topological awareness of the connectivity between nodes, would be
      able to compute more direct routes, avoiding the vicinity of the root
      whenever possible.
      </t>

      	  <t>With the initial specifications of RPL  <xref target="RFC6550"/>, the
     P2P path from a source to a destination is often stretched

          -->
     <t>
     It results that it is often beneficial to enable transversal P2P routes,
     either if the RPL route presents a stretch from shortest path, or if the
     new route is engineered with a different objective.
     For that reason, earlier work at the IETF introduced the
     <xref target="RFC6997">"Reactive Discovery of Point-to-Point Routes in
     Low Power and Lossy Networks"</xref>, which specifies a distributed method for
     establishing optimized P2P routes. This draft proposes an alternate based
     on a centralized route computation.
     </t>

        <figure  anchor="opti2" title="Projected Transversal Route">
            <artwork>
              ------+---------
                    |          Internet
                    |
                 +-----+
                 |     | Border Router
                 |     |  (RPL Root)
                 +-----+
                    |
              o    o   o    o
          o o   o  o   o  o  o o   o
         o  o o  o o    o   o   o  o  o
         o   o    o  o     o  o    o  o  o
        S>>A>>>B>>C>>>D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>
            <t>
      This specification enables to store source-routed or storing mode state in
      intermediate routers, which enables to limit the stretch of a P2P route
      and maintain the characteristics within a given SLA. An example of service
      using this mechanism oculd be a control loop that would be installed in a
      network that uses classical RPL for asynchronous data collection. In that
      case, the P2P path may be installed in a different RPL Instance, with a
      different objective function.
      </t>
      </section>
          <section title="Multipath Routing">
            <t>
                P-DAOs can be more effectively made use for establishing
                multi-path routing adjacencies because the root can view the
                DODAG holistically and make more appropriate decisions than the
                target node itself. A requirement for multi-path routing is
                that the different paths that are chosen should ideally be
                exclusive i.e. it is better not to have a common segment along
                the different paths. Since root has a full view of the network,
                it can project routes along the disjoint segments which can
                result in more optimal multi-path routing.
            </t>
            <t>
                TBD: Priority needs to be attached with every P-DAO for multipath routing.
            </t>
          </section>
      </section>




        <section title="RPL Instances">
     <t>
     It must be noted that RPL has a concept of instance but does not have a
     concept of an administrative distance, which exists in certain proprietary
     implementations to sort out conflicts between multiple sources of routing
     information. This draft conforms the instance model as follows:
     <list style="symbols">
     <t>
     If the PCE needs to influence a particular instance to add better routes
     in conformance with the routing objectives in that instance, it may do so.
     When the PCE modifies an existing instance then the added routes
     must not create a loop in that instance. This is achieved by always
     preferring a route obtained from the PCE over a route that is learned via
     RPL.</t>
     <t>
     If the PCE installs a more specific (say, Traffic Engineered) route between
     a particular pair of nodes then it SHOULD use a Local Instance from the
     ingress node of that path. A packet associated with that instance will
     be routed along that path and MUST NOT be placed over a Global Instance
     again. A packet that is placed on a Global Instance may be injected in the
     Local Instance based on node policy and the Local Instance paramenters.
     <!-- TODO: add config parm to the local instance -->
     </t>
     </list>
     In all cases, the path is indicated by a new Via Information option, and
     the flow is similar to the flow used to obtain loose source routing.
   </t>
    </section>


    <section title="Security Considerations">

	<t>This draft uses messages that are already present in RPL
     <xref target="RFC6550"/> with optional secured versions. The same secured
     versions may be used with this draft, and whatever security is deployed for
     a given network also applies to the flows in this draft.

	</t>
   </section>
   <section anchor="RPLCtrlMsgOptionsReg" title="IANA Considerations">

    <t>This document extends the IANA registry created by RFC 6550 for RPL
    Control Codes as follows:</t>

        <texttable title="RPL Control Codes">
          <ttcol align="center">Code</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>


          <c>0x0A</c>

          <c>Via</c>

          <c>This document</c>

          <c>0x0B</c>

          <c>Source-Routed Via</c>

          <c>This document</c>
        </texttable>



    <t>This document is updating the registry created by RFC 6550 for the RPL
        3-bit Mode of Operation (MOP) as follows:
        </t>

        <texttable title="DIO Mode of operation">
          <ttcol align="center">MOP value</ttcol>

          <ttcol align="left">Description</ttcol>

          <ttcol align="left">Reference</ttcol>

          <c>5</c>

          <c>Non-Storing mode of operation with Projected routes</c>

          <c>This document</c>

          <c>6</c>

          <c>Storing mode of operation with Projected routes</c>

          <c>This document</c>

        </texttable>
   </section>


<section title="Acknowledgments">
<t>The authors wish to acknowledge JP Vasseur and Patrick Wetterwald for their
 contributions to the ideas developed here.</t>
</section>

    </middle>

    <back>
    <references title='Normative References'>
	  <?rfc include="reference.RFC.2119"?>
	  <?rfc include="reference.RFC.6550"?>
	  <?rfc include="reference.RFC.6551"?>
	  <?rfc include="reference.RFC.6554"?>
	  <?rfc include="reference.RFC.8025"?>
	  <?rfc include="reference.RFC.8138"?>
	  <?rfc include="reference.RFC.8174"?>


    </references>
    <references title='Informative References'>

	  <?rfc include="reference.RFC.7102"?>
	   <?rfc include="reference.RFC.6997"?>
      <?rfc include='reference.I-D.ietf-6tisch-architecture'?>
      <?rfc include='reference.I-D.ietf-detnet-architecture'?>
      <reference anchor="PCE"
          target="https://datatracker.ietf.org/doc/charter-ietf-pce/">
         <front>
            <title>Path Computation Element</title>
            <author>
               <organization>IETF</organization>
            </author>
            <date></date>
         </front>
      </reference>

    </references>


    <section  title="Examples">

        <section title="Using storing mode P-DAO in non-storing mode MOP">
<t>
    In non-storing mode, the DAG root maintains the knowledge of the whole DODAG
    topology, so when both the source and the destination
    of a packet are in the DODAG, the root can determine the common
    parent that would have been used in storing mode, and thus the list of nodes
    in the path between the common parent and the destination. For instance in
    the diagram shown in <xref target="exmp"/>, if the source is node 41
    and the destination is node 52, then the common parent is node 22.
    </t>
       <figure anchor="exmp" title="Example DODAG forming a logical tree topology">
            <artwork>
           ------+---------
                 |          Internet
                 |
              +-----+
              |     | Border Router
              |     |  (RPL Root)
              +-----+
               | \  \____
              /   \       \
            o 11   o 12     o  13
           /       |       /  \
         o 22      o 23   o 24  o 25
        /  \       | \      \
      o 31   o 32  o   o     o 35
     /      /      |    \    |    \
    o 41   o 42    o     o   o 45   o 46
    |      |       |     |    \     |
    o 51   o 52    o 53  o     o 55 o 56

                       LLN
       </artwork>
          </figure>



    <t>
     With this draft, the root can install a storing mode routing states along a
     segment that is either from itself to the destination, or from one or more
     common parents for a particular source/destination pair towards that
     destination (in this particular
     example, this would be the segment made of nodes 22, 32, 42).
    </t><!--t>
     If the predecessor can route to the successor node, then it installs a
     route to the targets via the successor. If that route is not connected then
     a recursive lookup will take place to reach the target(s). From there,
     the node strips the last Via Information option and either answers to the
     root with a positive DAO-ACK that contains the list of targets that could
     be routed to, or propagates the DAO to its own predecessor.
    </t-->
    <t> In the example below, say that there is a lot of traffic to nodes 55 and
    56 and the root decides to reduce the size of routing headers to those
    destinations. The root can first send a DAO to node 45 indicating target 55
    and a Via segment (35, 45), as well as another DAO to node 46 indicating
    target 56 and a Via segment (35, 46). This will save one entry in the
    routing header on both sides. The root may then send a DAO to node 35
    indicating targets 55 and 56 a Via segment (13, 24, 35) to fully optimize
    that path.</t>
    <t>
    Alternatively, the root may send a DAO to node 45 indicating target 55
    and a Via segment (13, 24, 35, 45) and then a DAO to node 46 indicating
    target 56 and a Via segment (13, 24, 35, 46), indicating the same DAO
    Sequence.
    </t>
    <!--
    <t>
    It may happen that the nodes along the path do not have enough resources
    to store an additional route to the destination (node 46). As the root has a
    complete knowledge of the DAG, some nodes may have more compute and storing
    resources so that they can be elected as specific nodes (it is the case of
    node 35 for instance). Let's take the case where node
    45 send packets to node 56. node 46 is unable to store any route.

    </t><t>
    In this case the root send the new DAO message to node 35 (well known node
    for its compute and storing capabilities) with the routing header to node
    56 (segment 35 - 46).

    </t><t>
    When 35 receives from its child a packet to node 56, it adds the routing
    header to node 56 in the packet header. In this case nothing changes for
    the node 46 acting as non storing mode.

    </t><t>
      The life time of the DAO may be dynamically changed by the root.
      Once the routing state expires, and packets are router back to their
      original mode (through the root), the root may accordingly decide to
      refresh the state if the conditions that triggered the decision to install
      the state still holds, after potentially adjusting the life time.
    </t>
    -->


    </section>


    <section title="Projecting a storing-mode transversal route">


   <t>In this example, say that a PCE determines that a path must be installed
   between node S and node D via routers A, B and C, in order to serve the needs
   of a particular application.
   </t><t>
   The root sends a P-DAO with a target option indicating the destination D and
   a sequence Via Information option, one for S, which is the ingress router of
   the segment, one for A and then for B, which are an intermediate routers, and
   one for C, which is the egress router.
   </t>
       <figure  anchor="pdao2" title="Projected DAO from root">
            <artwork>
              ------+---------
                    |          Internet
                    |
                 +-----+
                 |     | Border Router
                 |     |  (RPL Root)
                 +-----+
                    | Projected DAO message to C
              o    |   o    o
          o o   o |    o  o  o o   o
         o  o o  | o    o   o   o  o  o
         o   o   V  o     o  o    o  o  o
        S  A  B  C   D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>

   <t>Upon reception of the P-DAO, C validates that it can reach D, e.g. using
   IPv6 Neighbor Discovery, and if so, propagates the P-DAO unchanged to B.
   </t><t>
   B checks that it can reach C and of so, installs a route towards D via C.
   Then it propagates the P-DAO to A.
   </t><t>
   The process recurses till the P-DAO reaches S, the ingress of the segment,
   which installs a route to D via A and sends a DAO-ACK to the root.
    </t>

          <figure  anchor="pdao3" title="Projected DAO-ACK to root">
            <artwork>
              ------+---------
                    |          Internet
                    |
                 +-----+
                 |     | Border Router
                 |     |  (RPL Root)
                 +-----+
                  ^ Projected DAO-ACK from S
              /    o   o    o
           /   o o    o  o  o o   o
         |  o o  o o    o   o   o  o  o
         |   o   o  o     o  o    o  o  o
        S  A  B  C   D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>

             <t>
   As a result, a transversal route is installed that does not need to follow
   the DODAG structure.
   </t>
       <figure  anchor="opti" title="Projected Transversal Route">
            <artwork>
              ------+---------
                    |          Internet
                    |
                 +-----+
                 |     | Border Router
                 |     |  (RPL Root)
                 +-----+
                    |
              o    o   o    o
          o o   o  o   o  o  o o   o
         o  o o  o o    o   o   o  o  o
         o   o    o  o     o  o    o  o  o
        S>>A>>>B>>C>>>D         o   o o
        o          o             o     o
                          LLN
       </artwork>
          </figure>
    </section>

    </section>
    </back>




</rfc>
